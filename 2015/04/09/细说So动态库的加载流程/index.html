<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>细说So动态库的加载流程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="dlopen之内存装载dlopen用来打开一个动态链接库，并将其装入内存。它的定义在Android源码中的路径为&#x2F;bionic&#x2F;linker&#x2F;dlfcn.cpp，执行流程如下：其核心代码在do_dlopen中实现，根据传入的路径或文件名去查找一个动态库，并执行该动态链接库的初始化代码。 1234567891011121314151617181920212223void">
<meta property="og:type" content="article">
<meta property="og:title" content="细说So动态库的加载流程">
<meta property="og:url" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="dlopen之内存装载dlopen用来打开一个动态链接库，并将其装入内存。它的定义在Android源码中的路径为&#x2F;bionic&#x2F;linker&#x2F;dlfcn.cpp，执行流程如下：其核心代码在do_dlopen中实现，根据传入的路径或文件名去查找一个动态库，并执行该动态链接库的初始化代码。 1234567891011121314151617181920212223void">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/so.jpg">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/7.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/8.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/11.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/12.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/13.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/14.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/15.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/16.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/load2.jpg">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/20.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/21.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/23.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/24.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/25.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/26.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/27.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/28.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/29.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/30.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/31.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/32.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/33.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/34.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/35.png">
<meta property="og:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/36.png">
<meta property="article:published_time" content="2015-04-09T05:52:18.000Z">
<meta property="article:modified_time" content="2019-02-02T10:55:37.640Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="ELF">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/so.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-细说So动态库的加载流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2015-04-09T05:52:18.000Z" itemprop="datePublished">2015-04-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      细说So动态库的加载流程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="dlopen之内存装载"><a href="#dlopen之内存装载" class="headerlink" title="dlopen之内存装载"></a>dlopen之内存装载</h2><p>dlopen用来打开一个动态链接库，并将其装入内存。它的定义在Android源码中的路径为&#x2F;bionic&#x2F;linker&#x2F;dlfcn.cpp，执行流程如下：<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/so.jpg" alt="dlopen执行流程">其核心代码在do_dlopen中实现，根据传入的路径或文件名去查找一个动态库，并执行该动态链接库的初始化代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> flags)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedPthreadMutexLocker <span class="title">locker</span><span class="params">(&amp;gDlMutex)</span></span>;</span><br><span class="line">  soinfo* result = <span class="built_in">do_dlopen</span>(filename, flags);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    __bionic_format_dlerror(<span class="string">&quot;dlopen failed&quot;</span>, <span class="built_in">linker_get_error_buffer</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">soinfo* <span class="title">do_dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((flags &amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid flags to dlopen: %x&quot;</span>, flags);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set_soinfo_pool_protection</span>(PROT_READ | PROT_WRITE);</span><br><span class="line">  soinfo* si = <span class="built_in">find_library</span>(name);</span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    si-&gt;<span class="built_in">CallConstructors</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set_soinfo_pool_protection</span>(PROT_READ);</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看find_library这个方法，它会先在solist（已经加载的动态链接库链表）里进行查找，如果找到了就返回对应的soinfo结构体指针。否则，就调用load_library进行加载。然后，调用soinfo_link_image方法，根据soinfo结构体解析相应的Section。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> soinfo *<span class="title">find_loaded_library</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    soinfo *si;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *bname;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> don&#x27;t use basename only for determining libraries</span></span><br><span class="line">    <span class="comment">// http://code.google.com/p/android/issues/detail?id=6670</span></span><br><span class="line"></span><br><span class="line">    bname = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    bname = bname ? bname + <span class="number">1</span> : name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (si = solist; si != <span class="literal">NULL</span>; si = si-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(bname, si-&gt;name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> soinfo* <span class="title">find_library_internal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> somain;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  soinfo* si = <span class="built_in">find_loaded_library</span>(name);</span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (si-&gt;flags &amp; FLAG_LINKED) &#123;</span><br><span class="line">      <span class="keyword">return</span> si;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;OOPS: recursive link to \&quot;%s\&quot;&quot;</span>, si-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;[ &#x27;%s&#x27; has not been loaded yet.  Locating...]&quot;</span>, name);</span><br><span class="line">  si = <span class="built_in">load_library</span>(name);</span><br><span class="line">  <span class="keyword">if</span> (si == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At this point we know that whatever is loaded @ base is a valid ELF</span></span><br><span class="line">  <span class="comment">// shared library whose segments are properly mapped in.</span></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;[ init_library base=0x%08x sz=0x%08x name=&#x27;%s&#x27; ]&quot;</span>,</span><br><span class="line">        si-&gt;base, si-&gt;size, si-&gt;name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">soinfo_link_image</span>(si)) &#123;</span><br><span class="line">    <span class="built_in">munmap</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(si-&gt;base), si-&gt;size);</span><br><span class="line">    <span class="built_in">soinfo_free</span>(si);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> soinfo* <span class="title">find_library</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">  soinfo* si = <span class="built_in">find_library_internal</span>(name);</span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    si-&gt;ref_count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load_library调用open_library打开一个动态链接库，返回一个句柄，将其与共享库所在的路径作为参数，对ElfReader进行初始化。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/7.png" alt="dlopen调用链"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/8.png" alt="dlopen调用链">ElfReader作用域中的Load函数，会执行以下操作：  </p>
<ol>
<li>读取并校验ELF文件头</li>
<li>读ELF程序头并映射至内存</li>
<li>将Load Segment加载进内存</li>
<li>在内存中找到程序的起始地址<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::Load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ReadElfHeader</span>() &amp;&amp;</span><br><span class="line">         <span class="built_in">VerifyElfHeader</span>() &amp;&amp;</span><br><span class="line">         <span class="built_in">ReadProgramHeader</span>() &amp;&amp;</span><br><span class="line">         <span class="built_in">ReserveAddressSpace</span>() &amp;&amp;</span><br><span class="line">         <span class="built_in">LoadSegments</span>() &amp;&amp;</span><br><span class="line">         <span class="built_in">FindPhdr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadElfHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">ssize_t</span> rc = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">read</span>(fd_, &amp;header_, <span class="built_in">sizeof</span>(header_)));</span><br><span class="line">  <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t read file \&quot;%s\&quot;: %s&quot;</span>, name_, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (rc != <span class="built_in">sizeof</span>(header_)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; is too small to be an ELF executable&quot;</span>, name_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><font color="#006666" size="3" face="黑体">**读ELF文件头**</font></center>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loads the program header table from an ELF file into a read-only private</span></span><br><span class="line"><span class="comment">// anonymous mmap-ed block.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadProgramHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  phdr_num_ = header_.e_phnum;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Like the kernel, we only accept program header tables that</span></span><br><span class="line">  <span class="comment">// are smaller than 64KiB.</span></span><br><span class="line">  <span class="keyword">if</span> (phdr_num_ &lt; <span class="number">1</span> || phdr_num_ &gt; <span class="number">65536</span>/<span class="built_in">sizeof</span>(Elf32_Phdr)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid e_phnum: %d&quot;</span>, name_, phdr_num_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Elf32_Addr page_min = <span class="built_in">PAGE_START</span>(header_.e_phoff);  <span class="comment">//页的起始地址</span></span><br><span class="line">  Elf32_Addr page_max = <span class="built_in">PAGE_END</span>(header_.e_phoff + (phdr_num_ * <span class="built_in">sizeof</span>(Elf32_Phdr)));  <span class="comment">//页的结束地址</span></span><br><span class="line">  Elf32_Addr page_offset = <span class="built_in">PAGE_OFFSET</span>(header_.e_phoff);  <span class="comment">//程序头部在页中的偏移</span></span><br><span class="line"></span><br><span class="line">  phdr_size_ = page_max - page_min;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* mmap_result = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, phdr_size_, PROT_READ, MAP_PRIVATE, fd_, page_min);  <span class="comment">//将程序头映射到内存</span></span><br><span class="line">  <span class="keyword">if</span> (mmap_result == MAP_FAILED) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; phdr mmap failed: %s&quot;</span>, name_, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  phdr_mmap_ = mmap_result;</span><br><span class="line">  phdr_table_ = <span class="built_in">reinterpret_cast</span>&lt;Elf32_Phdr*&gt;(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(mmap_result) + page_offset);  <span class="comment">//程序头表在内存中的地址</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><font color="#006666" size="3" face="黑体">**读ELF程序头，并映射到内存**</font></center>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reserve a virtual address range big enough to hold all loadable</span></span><br><span class="line"><span class="comment">// segments of a program header table. This is done by creating a</span></span><br><span class="line"><span class="comment">// private anonymous mmap() with PROT_NONE.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReserveAddressSpace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Elf32_Addr min_vaddr;</span><br><span class="line">  load_size_ = <span class="built_in">phdr_table_get_load_size</span>(phdr_table_, phdr_num_, &amp;min_vaddr);  <span class="comment">//根据页对齐来计算Load段所占用的大小</span></span><br><span class="line">  <span class="keyword">if</span> (load_size_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has no loadable segments&quot;</span>, name_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(min_vaddr);</span><br><span class="line">  <span class="type">int</span> mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS;  <span class="comment">//匿名私有</span></span><br><span class="line">  <span class="type">void</span>* start = <span class="built_in">mmap</span>(addr, load_size_, PROT_NONE, mmap_flags, <span class="number">-1</span>, <span class="number">0</span>);  <span class="comment">//调用mmap为动态库分配一块内存空间</span></span><br><span class="line">  <span class="keyword">if</span> (start == MAP_FAILED) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t reserve %d bytes of address space for \&quot;%s\&quot;&quot;</span>, load_size_, name_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  load_start_ = start;</span><br><span class="line">  load_bias_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(start) - addr;  <span class="comment">//真实的加载地址与计算出来的（读ELF程序头中的p_vaddr）加载地址之差</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><font color="#006666" size="3" face="黑体">**调用mmap申请一块足够大的内存空间，为后面进行映射Load段的映射做准备**</font></center>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map all loadable segments in process&#x27; address space.</span></span><br><span class="line"><span class="comment">// This assumes you already called phdr_table_reserve_memory to</span></span><br><span class="line"><span class="comment">// reserve the address space range for the library.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> assert assumption.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::LoadSegments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; phdr_num_; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> Elf32_Phdr* phdr = &amp;phdr_table_[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Segment addresses in memory.</span></span><br><span class="line">    Elf32_Addr seg_start = phdr-&gt;p_vaddr + load_bias_;</span><br><span class="line">    Elf32_Addr seg_end   = seg_start + phdr-&gt;p_memsz;</span><br><span class="line"></span><br><span class="line">    Elf32_Addr seg_page_start = <span class="built_in">PAGE_START</span>(seg_start);</span><br><span class="line">    Elf32_Addr seg_page_end   = <span class="built_in">PAGE_END</span>(seg_end);</span><br><span class="line"></span><br><span class="line">    Elf32_Addr seg_file_end   = seg_start + phdr-&gt;p_filesz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// File offsets.</span></span><br><span class="line">    Elf32_Addr file_start = phdr-&gt;p_offset;</span><br><span class="line">    Elf32_Addr file_end   = file_start + phdr-&gt;p_filesz;</span><br><span class="line"></span><br><span class="line">    Elf32_Addr file_page_start = <span class="built_in">PAGE_START</span>(file_start);</span><br><span class="line">    Elf32_Addr file_length = file_end - file_page_start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file_length != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">void</span>* seg_addr = <span class="built_in">mmap</span>((<span class="type">void</span>*)seg_page_start,          <span class="comment">//将Load Segment映射到内存，大小为在ELF文件中所占用的长度</span></span><br><span class="line">                            file_length,</span><br><span class="line">                            <span class="built_in">PFLAGS_TO_PROT</span>(phdr-&gt;p_flags),</span><br><span class="line">                            MAP_FIXED|MAP_PRIVATE,</span><br><span class="line">                            fd_,</span><br><span class="line">                            file_page_start);</span><br><span class="line">      <span class="keyword">if</span> (seg_addr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t map \&quot;%s\&quot; segment %d: %s&quot;</span>, name_, i, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the segment is writable, and does not end on a page boundary,</span></span><br><span class="line">    <span class="comment">// zero-fill it until the page limit.</span></span><br><span class="line">    <span class="keyword">if</span> ((phdr-&gt;p_flags &amp; PF_W) != <span class="number">0</span> &amp;&amp; <span class="built_in">PAGE_OFFSET</span>(seg_file_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span>*)seg_file_end, <span class="number">0</span>, PAGE_SIZE - <span class="built_in">PAGE_OFFSET</span>(seg_file_end));  <span class="comment">//如果这块Segment是可写的，且在内存中的结束地址不在页的边界上，则将后面的数据都填充0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    seg_file_end = <span class="built_in">PAGE_END</span>(seg_file_end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// seg_file_end is now the first page address after the file</span></span><br><span class="line">    <span class="comment">// content. If seg_end is larger, we need to zero anything</span></span><br><span class="line">    <span class="comment">// between them. This is done by using a private anonymous</span></span><br><span class="line">    <span class="comment">// map for all extra pages.</span></span><br><span class="line">    <span class="keyword">if</span> (seg_page_end &gt; seg_file_end) &#123;</span><br><span class="line">      <span class="type">void</span>* zeromap = <span class="built_in">mmap</span>((<span class="type">void</span>*)seg_file_end,                 <span class="comment">//如果seg_end大于它在文件中的长度，则继续为多出的那部分申请内存空间，并填充0。这里应该是主要针对bss段</span></span><br><span class="line">                           seg_page_end - seg_file_end,</span><br><span class="line">                           <span class="built_in">PFLAGS_TO_PROT</span>(phdr-&gt;p_flags),</span><br><span class="line">                           MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,</span><br><span class="line">                           <span class="number">-1</span>,</span><br><span class="line">                           <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (zeromap == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t zero fill \&quot;%s\&quot; gap: %s&quot;</span>, name_, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><font color="#006666" size="3" face="黑体">**将类型为Load的Segment映射到内存**</font></center>
接下来，soinfo_alloc方法会为该库在共享库链表中分配一个soinfo节点，并初始化其数据结构。
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> soinfo* <span class="title">load_library</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Open the file.</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open_library</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; not found&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the ELF header and load the segments.</span></span><br><span class="line">    <span class="function">ElfReader <span class="title">elf_reader</span><span class="params">(name, fd)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!elf_reader.<span class="built_in">Load</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* bname = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    soinfo* si = <span class="built_in">soinfo_alloc</span>(bname ? bname + <span class="number">1</span> : name);</span><br><span class="line">    <span class="keyword">if</span> (si == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    si-&gt;base = elf_reader.<span class="built_in">load_start</span>();</span><br><span class="line">    si-&gt;size = elf_reader.<span class="built_in">load_size</span>();</span><br><span class="line">    si-&gt;load_bias = elf_reader.<span class="built_in">load_bias</span>();</span><br><span class="line">    si-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    si-&gt;entry = <span class="number">0</span>;</span><br><span class="line">    si-&gt;dynamic = <span class="literal">NULL</span>;</span><br><span class="line">    si-&gt;phnum = elf_reader.<span class="built_in">phdr_count</span>();</span><br><span class="line">    si-&gt;phdr = elf_reader.<span class="built_in">loaded_phdr</span>();</span><br><span class="line">    <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> soinfo* <span class="title">soinfo_alloc</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(name) &gt;= SOINFO_NAME_LEN) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;library name \&quot;%s\&quot; too long&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ensure_free_list_non_empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;out of memory when loading \&quot;%s\&quot;&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Take the head element off the free list.</span></span><br><span class="line">  soinfo* si = gSoInfoFreeList;</span><br><span class="line">  gSoInfoFreeList = gSoInfoFreeList-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the new element.</span></span><br><span class="line">  <span class="built_in">memset</span>(si, <span class="number">0</span>, <span class="built_in">sizeof</span>(soinfo));</span><br><span class="line">  <span class="built_in">strlcpy</span>(si-&gt;name, name, <span class="built_in">sizeof</span>(si-&gt;name));</span><br><span class="line">  sonext-&gt;next = si;</span><br><span class="line">  sonext = si;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;name %s: allocated soinfo @ %p&quot;</span>, name, si);</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
再回过头来看下soinfo_link_image这个方法，它主要实现了动态链接库中section信息的解析：  </li>
<li>先解析dynamic section动态节区，进而实现各个Section的定位；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/11.png" alt="解析section"></li>
<li>获取其他Section的信息；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/12.png" alt="解析section"></li>
<li>待所有section信息解析完毕后，对HASH,STRTAB,SYMTAB节是否正常解析做校验；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/13.png" alt="解析section"></li>
<li>若标志位有FLAG_EXE，则表示当前程序执行的是一个可执行文件。到这里可以确定，linker不仅负责加载so，也负责解析加载一个可执行的ELF文件；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/14.png" alt="解析section"></li>
<li>加载所需要的其他共享库，其中find_library会递归调用这个so_link_image函数，直到某个so库没有DT_NEEDED段；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/15.png" alt="解析section"></li>
<li>完成rel节的重定位；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/16.png" alt="解析section">最后，CallConstructors函数会根据动态节区中的信息，获取该共享库所依赖的所有so文件名，并在已加载的动态链接库链表中进行查找、递归调用它们的初始化函数。当运行所需的依赖库都初始化完成后，再执行init_func、init_array方法初始化该动态库。。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">soinfo::CallConstructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (constructors_called) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We set constructors_called before actually calling the constructors, otherwise it doesn&#x27;t</span></span><br><span class="line">  <span class="comment">// protect against recursive constructor calls. One simple example of constructor recursion</span></span><br><span class="line">  <span class="comment">// is the libc debug malloc, which is implemented in libc_malloc_debug_leak.so:</span></span><br><span class="line">  <span class="comment">// 1. The program depends on libc, so libc&#x27;s constructor is called here.</span></span><br><span class="line">  <span class="comment">// 2. The libc constructor calls dlopen() to load libc_malloc_debug_leak.so.</span></span><br><span class="line">  <span class="comment">// 3. dlopen() calls the constructors on the newly created</span></span><br><span class="line">  <span class="comment">//    soinfo for libc_malloc_debug_leak.so.</span></span><br><span class="line">  <span class="comment">// 4. The debug .so depends on libc, so CallConstructors is</span></span><br><span class="line">  <span class="comment">//    called again with the libc soinfo. If it doesn&#x27;t trigger the early-</span></span><br><span class="line">  <span class="comment">//    out above, the libc constructor will be called again (recursively!).</span></span><br><span class="line">  constructors_called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((flags &amp; FLAG_EXE) == <span class="number">0</span> &amp;&amp; preinit_array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// The GNU dynamic linker silently ignores these, but we warn the developer.</span></span><br><span class="line">    <span class="built_in">PRINT</span>(<span class="string">&quot;\&quot;%s\&quot;: ignoring %d-entry DT_PREINIT_ARRAY in shared library!&quot;</span>,</span><br><span class="line">          name, preinit_array_count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dynamic != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Elf32_Dyn* d = dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">      <span class="keyword">if</span> (d-&gt;d_tag == DT_NEEDED) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* library_name = strtab + d-&gt;d_un.d_val;</span><br><span class="line">        <span class="built_in">TRACE</span>(<span class="string">&quot;\&quot;%s\&quot;: calling constructors in DT_NEEDED \&quot;%s\&quot;&quot;</span>, name, library_name);</span><br><span class="line">        <span class="built_in">find_loaded_library</span>(library_name)-&gt;<span class="built_in">CallConstructors</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;\&quot;%s\&quot;: calling constructors&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DT_INIT should be called before DT_INIT_ARRAY if both are present.</span></span><br><span class="line">  <span class="built_in">CallFunction</span>(<span class="string">&quot;DT_INIT&quot;</span>, init_func);</span><br><span class="line">  <span class="built_in">CallArray</span>(<span class="string">&quot;DT_INIT_ARRAY&quot;</span>, init_array, init_array_count, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="loadLibrary之加载调用"><a href="#loadLibrary之加载调用" class="headerlink" title="loadLibrary之加载调用"></a>loadLibrary之加载调用</h2><p>Java层通过System.load或System.loadLibrary来加载一个so文件，它的定义在Android源码中的路径为&#x2F;libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;System.java，执行流程如下：<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/load2.jpg" alt="loadLibrary执行流程">接下来，让我们具体看下System.loadLibrary这个方法的实现。可以发现它实际是先通过VMStack.getCallingClassLoader()获取到ClassLoader，然后调用运行时的loadLibrary。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads and links the library with the specified name. The mapping of the</span></span><br><span class="line"><span class="comment"> * specified library name to the full path for loading the library is</span></span><br><span class="line"><span class="comment"> * implementation-dependent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> libName</span></span><br><span class="line"><span class="comment"> *            the name of the library to load.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsatisfiedLinkError</span></span><br><span class="line"><span class="comment"> *             if the library can not be loaded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadLibrary</span><span class="params">(String libName)</span> &#123;</span><br><span class="line">    loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Searches for a library, then loads and links it without security checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadLibrary</span><span class="params">(String libraryName, ClassLoader loader)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> loader.findLibrary(libraryName);</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkError</span>(<span class="string">&quot;Couldn&#x27;t load &quot;</span> + libraryName +</span><br><span class="line">                                           <span class="string">&quot; from loader &quot;</span> + loader +</span><br><span class="line">                                           <span class="string">&quot;: findLibrary returned null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">error</span> <span class="operator">=</span> doLoad(filename, loader);</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkError</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> System.mapLibraryName(libraryName);</span><br><span class="line">    List&lt;String&gt; candidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">lastError</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String directory : mLibPaths) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">candidate</span> <span class="operator">=</span> directory + filename;</span><br><span class="line">        candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">error</span> <span class="operator">=</span> doLoad(candidate, loader);</span><br><span class="line">            <span class="keyword">if</span> (error == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">            &#125;</span><br><span class="line">            lastError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastError != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkError</span>(lastError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkError</span>(<span class="string">&quot;Library &quot;</span> + libraryName + <span class="string">&quot; not found; tried &quot;</span> + candidates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码块的主要功能为：</p>
<blockquote>
</blockquote>
<ol>
<li>若ClassLoader非空，则利用ClassLoader的findLibrary方法来获取library的path；  </li>
<li>若ClassLoader为空，则根据传递进来的libraryName，获取到library file的name（比如传递“test”进来，经过System.mapLibraryName方法的调用，返回的会是“libtest.so”）。然后再在一个path list（即下面代码截图中的mLibPaths）中查找到这个library file，并最终确定library 的path；  </li>
<li>调用nativeLoad这个jni方法来load library。</li>
</ol>
<p>然而，这里其实又牵扯出了几个问题：首先，可用的library path都是哪些？这实际上也决定了我们的so文件放在哪些目录下，才可以真正的被load起来。其次，在native层的nativeLoad又是如何实现加载的？下面会对这两个问题，逐一分析介绍。。</p>
<h3 id="So的加载路径"><a href="#So的加载路径" class="headerlink" title="So的加载路径"></a>So的加载路径</h3><p>先来看看当传入的ClassLoader为空的情况(执行System.loadLibrary时并不会发生)，那么就需要关注下mLibPaths的赋值，相应代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Runtime</span> <span class="variable">mRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds the library paths, used for native library lookup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] mLibPaths = initLibPaths();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] initLibPaths() &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">javaLibraryPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.library.path&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (javaLibraryPath == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyArray.STRING;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] paths = javaLibraryPath.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="comment">// Add a &#x27;/&#x27; to the end of each directory so we don&#x27;t have to do it every time.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; paths.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!paths[i].endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            paths[i] += <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里library path list实际上读取自一个system property，直接到System.java下查看初始化代码，它其实是LD_LIBRARY_PATH环境变量的值，具体内容可以查看注释，为”&#x2F;vendor&#x2F;lib:&#x2F;system&#x2F;lib”<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/20.png" alt="library path list"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/21.png" alt="library path list">然后再来看下传入的ClassLoader非空的情况，也就是ClassLoader的findLibrary的执行过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the absolute path of the native library with the specified name,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125;. If this method returns &#123;<span class="doctag">@code</span> null&#125; then the virtual</span></span><br><span class="line"><span class="comment"> * machine searches the directories specified by the system property</span></span><br><span class="line"><span class="comment"> * &quot;java.library.path&quot;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This implementation always returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> libName</span></span><br><span class="line"><span class="comment"> *            the name of the library to find.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the absolute path of the library.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">findLibrary</span><span class="params">(String libName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果发现竟然是一个空函数，而ClassLoader本身也只是个抽象类，那系统中实际运行的ClassLoader是哪个呢？这里可以写个小程序，将实际运行的ClassLoader输出：<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/23.png" alt="小程序"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/24.png" alt="日志打印">于是，得知android系统中ClassLoader真正的实现在dalvik.system.PathClassLoader。此外，在这条日志中，还顺带将PathClassLoader初始化的参数一同打印了出来。其中，libraryPath为”&#x2F;data&#x2F;app-lib&#x2F;elf.xuexi-1”..<br>不过PathClassLoader只是继承 BaseDexClassLoader，并没有实际内容。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/25.png" alt="PathClassLoader">继续到BaseDexClassLoader下看findLibrary的实现。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/26.png" alt="BaseDexClassLoader"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/27.png" alt="BaseDexClassLoader">可以看到，这里又是在调用DexPathList类下的findLibrary。关注splitLibraryPath方法，它返回了需要加载的动态库所在目录。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/28.png" alt="DexPathList"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/29.png" alt="DexPathList">这里简单说下splitLibraryPath方法的作用，它是根据传进来的libraryPath和system property中”java.library.path”的属性值即“&#x2F;vendor&#x2F;lib:&#x2F;system&#x2F;lib”来构造出要加载的动态库所在目录列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Splits the given library directory path string into elements</span></span><br><span class="line"><span class="comment"> * using the path separator (&#123;<span class="doctag">@code</span> File.pathSeparator&#125;, which</span></span><br><span class="line"><span class="comment"> * defaults to &#123;<span class="doctag">@code</span> &quot;:&quot;&#125; on Android, appending on the elements</span></span><br><span class="line"><span class="comment"> * from the system library path, and pruning out any elements that</span></span><br><span class="line"><span class="comment"> * do not refer to existing and readable directories.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File[] splitLibraryPath(String path) &#123;</span><br><span class="line">    <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">    <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   1. this class loader&#x27;s library path for application libraries</span></span><br><span class="line">    <span class="comment">//   2. the VM&#x27;s library path from the system property for system libraries</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line">    ArrayList&lt;File&gt; result = splitPaths(path, System.getProperty(<span class="string">&quot;java.library.path&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">File</span>[result.size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Splits the given path strings into file elements using the path</span></span><br><span class="line"><span class="comment"> * separator, combining the results and filtering out elements</span></span><br><span class="line"><span class="comment"> * that don&#x27;t exist, aren&#x27;t readable, or aren&#x27;t either a regular</span></span><br><span class="line"><span class="comment"> * file or a directory (as specified). Either string may be empty</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125;, in which case it is ignored. If both strings</span></span><br><span class="line"><span class="comment"> * are empty or &#123;<span class="doctag">@code</span> null&#125;, or all elements get pruned out, then</span></span><br><span class="line"><span class="comment"> * this returns a zero-element list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;File&gt; <span class="title function_">splitPaths</span><span class="params">(String path1, String path2,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> wantDirectories)</span> &#123;</span><br><span class="line">    ArrayList&lt;File&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;File&gt;();</span><br><span class="line">    splitAndAdd(path1, wantDirectories, result);</span><br><span class="line">    splitAndAdd(path2, wantDirectories, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helper for &#123;<span class="doctag">@link</span> #splitPaths&#125;, which does the actual splitting</span></span><br><span class="line"><span class="comment"> * and filtering and adding to a result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">splitAndAdd</span><span class="params">(String searchPath, <span class="type">boolean</span> directoriesOnly,</span></span><br><span class="line"><span class="params">        ArrayList&lt;File&gt; resultList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (searchPath == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String path : searchPath.split(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">StructStat</span> <span class="variable">sb</span> <span class="operator">=</span> Libcore.os.stat(path);</span><br><span class="line">            <span class="keyword">if</span> (!directoriesOnly || S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">                resultList.add(<span class="keyword">new</span> <span class="title class_">File</span>(path));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以对动态链接库的加载路径做个总结了，系统默认的目录为”&#x2F;vendor&#x2F;lib”和”&#x2F;system&#x2F;lib”。当使用System.loadLibrary或System.load来加载一个共享库的时候，会将VM栈中的ClassLoader传入。之后调用findLibrary方法，在两个目录中去寻找指定的so文件：一个是构造ClassLoader时，传进来的那个libraryPath；另一个则是system property中”java.library.path”的属性值。也就是说，实际上是会在如下的3个目录中进行查找：</p>
<blockquote>
</blockquote>
<ol>
<li>“&#x2F;vendor&#x2F;lib”</li>
<li>“&#x2F;system&#x2F;lib”</li>
<li>“&#x2F;data&#x2F;app-lib&#x2F;包名-n”</li>
</ol>
<p>对于”&#x2F;data&#x2F;app-lib&#x2F;包名-n”这个路径，大家可能会比较陌生，但应该都知道”&#x2F;data&#x2F;data&#x2F;包名&#x2F;lib”目录，这里就简单讲解下apk安装过程中的一点细节，以说明二者之间的关系（在Android源码中的路径为”&#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;installd&#x2F;commands.c”）  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">install</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgname, <span class="type">uid_t</span> uid, <span class="type">gid_t</span> gid, <span class="type">const</span> <span class="type">char</span> *seinfo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> pkgdir[PKG_PATH_MAX];</span><br><span class="line">    <span class="type">char</span> libsymlink[PKG_PATH_MAX];</span><br><span class="line">    <span class="type">char</span> applibdir[PKG_PATH_MAX];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">libStat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uid &lt; AID_SYSTEM) || (gid &lt; AID_SYSTEM)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;invalid uid/gid: %d %d\n&quot;</span>, uid, gid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_pkg_path(pkgdir, pkgname, PKG_DIR_POSTFIX, <span class="number">0</span>)) &#123;  <span class="comment">//创建包路径，&quot;/data/data/包名&quot;</span></span><br><span class="line">        ALOGE(<span class="string">&quot;cannot create package path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_pkg_path(libsymlink, pkgname, PKG_LIB_POSTFIX, <span class="number">0</span>)) &#123;  <span class="comment">//创建库路径，&quot;/data/data/包名/lib&quot;</span></span><br><span class="line">        ALOGE(<span class="string">&quot;cannot create package lib symlink origin path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_pkg_path_in_dir(applibdir, &amp;android_app_lib_dir, pkgname, PKG_DIR_POSTFIX)) &#123;  <span class="comment">//创建&quot;/data/app-lib/包名&quot;目录</span></span><br><span class="line">        ALOGE(<span class="string">&quot;cannot create package lib symlink dest path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mkdir(pkgdir, <span class="number">0751</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot create dir &#x27;%s&#x27;: %s\n&quot;</span>, pkgdir, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chmod(pkgdir, <span class="number">0751</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot chmod dir &#x27;%s&#x27;: %s\n&quot;</span>, pkgdir, strerror(errno));</span><br><span class="line">        unlink(pkgdir);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lstat(libsymlink, &amp;libStat) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != ENOENT) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;couldn&#x27;t stat lib dir: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(libStat.st_mode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (delete_dir_contents(libsymlink, <span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;couldn&#x27;t delete lib directory during install for: %s&quot;</span>, libsymlink);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(libStat.st_mode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unlink(libsymlink) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;couldn&#x27;t unlink lib directory during install for: %s&quot;</span>, libsymlink);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (symlink(applibdir, libsymlink) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;couldn&#x27;t symlink directory &#x27;%s&#x27; -&gt; &#x27;%s&#x27;: %s\n&quot;</span>, libsymlink, applibdir,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        unlink(pkgdir);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selinux_android_setfilecon2(pkgdir, pkgname, seinfo, uid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot setfilecon dir &#x27;%s&#x27;: %s\n&quot;</span>, pkgdir, strerror(errno));</span><br><span class="line">        unlink(libsymlink);</span><br><span class="line">        unlink(pkgdir);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chown(pkgdir, uid, gid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot chown dir &#x27;%s&#x27;: %s\n&quot;</span>, pkgdir, strerror(errno));</span><br><span class="line">        unlink(libsymlink);</span><br><span class="line">        unlink(pkgdir);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会先构造几个目录名：pkgdir为”&#x2F;data&#x2F;data&#x2F;包名”，libsymlink为”&#x2F;data&#x2F;data&#x2F;包名&#x2F;lib”，applibdir为”&#x2F;data&#x2F;app-lib&#x2F;包名”。然后创建相应目录，并赋权限。之后，建立”&#x2F;data&#x2F;data&#x2F;包名&#x2F;lib”指向”&#x2F;data&#x2F;app-lib&#x2F;包名”的符号链接。<br>现在再回过头来说明下”&#x2F;data&#x2F;app-lib&#x2F;包名-n”、”&#x2F;data&#x2F;data&#x2F;包名&#x2F;lib”这二者之间的关系。在”&#x2F;data&#x2F;data&#x2F;包名&#x2F;“目录下执行ls –l命令，就会发现lib是一个链接，So其实是放在”&#x2F;data&#x2F;app-lib&#x2F;包名-n”路径下的。。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/30.png" alt="ls -l"></p>
<h3 id="Native-层的加载实现"><a href="#Native-层的加载实现" class="headerlink" title="Native 层的加载实现"></a>Native 层的加载实现</h3><p>doLoad实际上是调用本地的nativeLoad方法，nativeLoad会先更新LD_LIBRARY_PATH，然后执行dvmLoadNativeCode函数，真正实现so文件的加载。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * static String nativeLoad(String filename, ClassLoader loader, String ldLibraryPath)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Load the specified full path as a dynamic library filled with</span></span><br><span class="line"><span class="comment"> * JNI-compatible methods. Returns null on success, or a failure</span></span><br><span class="line"><span class="comment"> * message on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Dalvik_java_lang_Runtime_nativeLoad</span><span class="params">(<span class="type">const</span> u4* args,</span></span></span><br><span class="line"><span class="params"><span class="function">    JValue* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StringObject* fileNameObj = (StringObject*) args[<span class="number">0</span>];</span><br><span class="line">    Object* classLoader = (Object*) args[<span class="number">1</span>];</span><br><span class="line">    StringObject* ldLibraryPathObj = (StringObject*) args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(fileNameObj != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span>* fileName = <span class="built_in">dvmCreateCstrFromString</span>(fileNameObj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ldLibraryPathObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* ldLibraryPath = <span class="built_in">dvmCreateCstrFromString</span>(ldLibraryPathObj);</span><br><span class="line">        <span class="type">void</span>* sym = <span class="built_in">dlsym</span>(RTLD_DEFAULT, <span class="string">&quot;android_update_LD_LIBRARY_PATH&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sym != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fn)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line">            Fn android_update_LD_LIBRARY_PATH = <span class="built_in">reinterpret_cast</span>&lt;Fn&gt;(sym);</span><br><span class="line">            (*android_update_LD_LIBRARY_PATH)(ldLibraryPath);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;android_update_LD_LIBRARY_PATH not found; .so dependencies will not work!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(ldLibraryPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringObject* result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* reason = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="built_in">dvmLoadNativeCode</span>(fileName, classLoader, &amp;reason);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* msg = (reason != <span class="literal">NULL</span>) ? reason : <span class="string">&quot;unknown failure&quot;</span>;</span><br><span class="line">        result = <span class="built_in">dvmCreateStringFromCstr</span>(msg);</span><br><span class="line">        <span class="built_in">dvmReleaseTrackedAlloc</span>((Object*) result, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(reason);</span><br><span class="line">    <span class="built_in">free</span>(fileName);</span><br><span class="line">    <span class="built_in">RETURN_PTR</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dvmLoadNativeCode定义在Android源码中的路径为&#x2F;dalvik&#x2F;vm&#x2F;Native.cpp，它的主要功能如下：  </p>
<ol>
<li>调用findSharedLibEntry方法，遍历查找已加载的lib。具体来说，就是先用待加载的lib路径名计算出一个32位hash值，然后遍历gDvm中的nativeLibs（其结构为HashTable用来保存加载的本地库），如果找到则返回一个SharedLib结构。这里如果LIB已被加载，则会对其加载的ClassLoader进行比较，JNI只允许同一个LIB只被一个ClassLoader加载;<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/31.png" alt="dvmLoadNativeCode"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/32.png" alt="dvmLoadNativeCode"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/33.png" alt="dvmLoadNativeCode"></li>
<li>调用dlopen打开一个so;<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/34.png" alt="dvmLoadNativeCode"></li>
<li>将新加载的LIB插入到gDvm保存的链表中，执行JNI_OnLoad的调用。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/35.png" alt="dvmLoadNativeCode"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/36.png" alt="dvmLoadNativeCode"></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在了解So在内存中的加载原理后，可以得知以下几点：</p>
<blockquote>
</blockquote>
<ol>
<li>So的加载路径为：”&#x2F;vendor&#x2F;lib”、”&#x2F;system&#x2F;lib”、”&#x2F;data&#x2F;app-lib&#x2F;包名-n”;</li>
<li>So的入口为init_array、init_func这些初始化函数。这部分在dlopen的过程中就会执行，再之后的是JNI_Onload方法的调用。这里面可以注册一些本地方法，也可以继续做些变量的初始化等操作;</li>
<li>在So的加载流程中，最终会被存放到SharedLib这个结构体中，并添加到nativeLibs这个hash表下。。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" data-id="cl4c3fkil001spcw1abob4dl9" data-title="细说So动态库的加载流程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/" rel="tag">ELF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/04/17/%E6%B5%85%E8%B0%88ELF%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          浅谈ELF可执行文件的启动流程
        
      </div>
    </a>
  
  
    <a href="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ELF文件结构详解</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/">智能设备</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%89%A9%E8%81%94%E7%BD%91/">物联网</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E/">虚拟现实</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%BB%91%E4%BA%A7%E7%A0%94%E7%A9%B6/">黑产研究</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BLE/" rel="tag">BLE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ELF/" rel="tag">ELF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ROM/" rel="tag">ROM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/" rel="tag">业务安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E6%B7%B7%E6%B7%86/" rel="tag">反混淆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" rel="tag">学习总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/" rel="tag">恶意代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" rel="tag">文件格式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B/" rel="tag">模拟器检测</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B4%E6%92%AD%E4%BA%BA%E6%B0%94/" rel="tag">直播人气</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/" rel="tag">知识梳理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%83%E7%A0%94/" rel="tag">调研</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%86%E5%90%91/" rel="tag">逆向</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/" rel="tag">重放攻击</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BLE/" style="font-size: 13.33px;">BLE</a> <a href="/tags/ELF/" style="font-size: 20px;">ELF</a> <a href="/tags/ROM/" style="font-size: 10px;">ROM</a> <a href="/tags/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/" style="font-size: 10px;">业务安全</a> <a href="/tags/%E5%8F%8D%E6%B7%B7%E6%B7%86/" style="font-size: 10px;">反混淆</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" style="font-size: 10px;">学习总结</a> <a href="/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">恶意代码</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" style="font-size: 10px;">文件格式</a> <a href="/tags/%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B/" style="font-size: 13.33px;">模拟器检测</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 16.67px;">源码分析</a> <a href="/tags/%E7%9B%B4%E6%92%AD%E4%BA%BA%E6%B0%94/" style="font-size: 10px;">直播人气</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/" style="font-size: 13.33px;">知识梳理</a> <a href="/tags/%E8%B0%83%E7%A0%94/" style="font-size: 13.33px;">调研</a> <a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 13.33px;">逆向</a> <a href="/tags/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/" style="font-size: 10px;">重放攻击</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/28/OLLVM%E9%80%9A%E7%94%A8%E5%8F%8D%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%A0%94%E7%A9%B6/">OLLVM通用反平坦化研究</a>
          </li>
        
          <li>
            <a href="/2018/05/10/Android%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86/">Android模拟器检测体系梳理</a>
          </li>
        
          <li>
            <a href="/2018/04/21/%E8%B5%B7%E5%BA%95%E8%96%85%E7%BE%8A%E6%AF%9B%E7%81%B0%E8%89%B2%E4%BA%A7%E4%B8%9A%E9%93%BE/">起底薅羊毛灰色产业链</a>
          </li>
        
          <li>
            <a href="/2018/03/10/%E5%9F%BA%E4%BA%8ECache%E7%9A%84Android%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B/">基于Cache的Android模拟器检测</a>
          </li>
        
          <li>
            <a href="/2018/02/26/%E5%85%AD%E9%97%B4%E6%88%BF%E7%9B%B4%E6%92%AD%E5%88%B7%E4%BA%BA%E6%B0%94/">六间房直播刷人气</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>