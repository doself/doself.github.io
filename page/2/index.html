<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-LBE主动防御逆向分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2015-06-30T08:30:12.000Z" itemprop="datePublished">2015-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/">LBE主动防御逆向</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>运行程序，LBEApplication会释放assets&#x2F;hips.jar文件，解压缩至app_hips目录。开启主动防御功能后，会申请获取su权限，运行bootstrap可执行文件。<br><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/1.png" alt="hips.jar目录结构"></p>
<center><font size="3" face="黑体">**hips.jar目录结构**</font></center>
![获取su权限，运行bootstrap可执行文件](LBE主动防御逆向分析/2.png)
<center><font size="3" face="黑体">**获取su权限，运行bootstrap可执行文件**</font></center>

<h2 id="Bootstrap：关闭selinux，运行core-jar"><a href="#Bootstrap：关闭selinux，运行core-jar" class="headerlink" title="Bootstrap：关闭selinux，运行core.jar"></a>Bootstrap：关闭selinux，运行core.jar</h2><p>Bootstrap文件的作用就是关闭selinux安全机制，为后续的注入工作做准备，并运行core.jar文件。<br><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/3.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/4.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/5.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/6.png"></p>
<center><font size="3" face="黑体">**直接判断”/sys/fs/selinux”是否为SELINUX_MAGIC，确认是否为selinux目录**</font></center>
![](LBE主动防御逆向分析/7.png)
<center><font size="3" face="黑体">**通过在/proc/filesystems中找"selinuxfs"，再在"/proc/mounts"中找"selinuxfs"定位selinux目录**</font></center>
![](LBE主动防御逆向分析/8.png)
<center><font size="3" face="黑体">**关闭selinux**</font></center>

<h2 id="core-jar-amp-amp-core-so：实现进程注入"><a href="#core-jar-amp-amp-core-so：实现进程注入" class="headerlink" title="core.jar&amp;&amp;core.so：实现进程注入"></a>core.jar&amp;&amp;core.so：实现进程注入</h2><p>core.jar包中的主要功能就是将client.jar、client.so注入到所有父进程为Zygote进程的子进程中，并将service.jar和service.so注入到system_server目标进程。<br><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/9.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/10.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/11.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/12.png"></p>
<center><font size="3" face="黑体">**core.so 中的 JNINativeMethod结构体**</font></center>
![](LBE主动防御逆向分析/13.png)
<center><font size="3" face="黑体">**通过 /proc/pid/cmdline 文件获取进程pid**</font></center>
注入代码的具体实现如下：  
![](LBE主动防御逆向分析/14.png)![](LBE主动防御逆向分析/15.png)
<center><font size="3" face="黑体">**获取本地某个模块的起始地址**</font></center>
先调用dlsym方法获取在当前进程下，mmap、dlopen、dlsym等符号的地址。并计算在该进程中指定的so文件的起始地址与在目标进程中的起始地址的偏移差，从而得到指定函数在目的进程中的虚拟地址。
![](LBE主动防御逆向分析/16.png)这里计算在soinfo结构体中base基地址的偏移：（128+4+4+4）/4=35  
![](LBE主动防御逆向分析/17.png)目标进程中所有寄存器的值，被保存到v75指针中。查看pt_regs结构体，可以得知ida中解析出v75、v76、v77这些变量分别对应ARM_r0、ARM_r1、ARM_r2等寄存器。结合后面的分析，可以发现这里是在设置mmap方法所要调用的参数值。需要注意的是，当有4个以上的参数时，多出的参数会写在sp堆栈里。之后，将PC寄存器的值设置为目标进程中mmap函数的地址，并继续执行，实现函数调用。  
![](LBE主动防御逆向分析/18.png)![](LBE主动防御逆向分析/19.png)在目标进程中调用mmap申请内存空间后，就可以将要注入的so写入到那片内存，再通过dlopen、dlsym来获取指定函数地址，并调用。  
![](LBE主动防御逆向分析/20.png)![](LBE主动防御逆向分析/21.png)![](LBE主动防御逆向分析/22.png)

<h2 id="实现类加载器，回调java代码"><a href="#实现类加载器，回调java代码" class="headerlink" title="实现类加载器，回调java代码"></a>实现类加载器，回调java代码</h2><p>成功注入后，会调用client.so中的loadClient、service.so中的loadService方法。这2个函数都实现了一个类加载器，会加载对应的jar包，并反射调用java层的指定代码，为后续的hook做准备。<br><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/23.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/24.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/25.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/26.png"></p>
<h2 id="client-jar分析"><a href="#client-jar分析" class="headerlink" title="client.jar分析"></a>client.jar分析</h2><p>ClientContainer类下的initialize方法，会通过反射获取当前ActivityThread对象的mInstrumentation成员和mH成员的mCallback属性，并将其替换为本地继承了Callback、Instrumentation的自定义类。其中mInstrumentation用于监控应用程序与系统的交互，mH对应的内部类H处理从AMS接收到的消息，从而实现拦截Activity生命周期回调的HOOK功能，这个方式和金山的比较类似。。<br><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/27.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/28.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/29.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/30.png"></p>
<center><font size="3" face="黑体">**ApplicationThread与AMS通过H类的对象mH进行交互，并在handleMessage中处理**</font></center>
![](LBE主动防御逆向分析/31.png)这里简单分析下系统源码，当mH接收到从ActivityMangerService服务的RESUME_ACTIVITY消息时，会调用handleResumeActivity方法，并跳转callActivityOnResume函数，最终调用Activity的onResume方法，使一个Activity变得可见。而注入到应用进程的client.jar会hook当前ActivityThread对象的mInstrumentation成员为com/lbe/security/service/core/client/b/y类（继承了Instrumentation），并在原本的方法上添加了一些代码，达到拦截广告的目的。还是以callActivityOnResume为例，可以发现它在实现了Instrumentation父类中的callActivityOnResume方法后，又做了一次跳转，com/lbe/security/service/core/client/b/z只是一个接口，实际指向com/lbe/security/service/core/client/b下的相应方法，最后调用AdBlockClient类实现广告拦截（具体实现还没有看完，但是感觉和金山毒霸的原理应该是很相近的）。  
![](LBE主动防御逆向分析/32.png)![](LBE主动防御逆向分析/33.png)![](LBE主动防御逆向分析/34.png)

<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ol>
<li>对于将service.jar、service.so注入到System_service进程中的作用不是很清楚，相关的hook拦截即主动防御的功能基本都是在client.jar、client.so中实现的。因为要与底层服务进行通信，所以要注入这个进程？</li>
<li>跟进nativeenablehook方法，发现它会为android.webkit.BrowserFrame、com.android.org.chromium.content.browser.ContentViewCore类动态注册nativeloadurl、nativePostUrl、nativeLoadData本地方法。但是这些函数在对应的类路径（系统类）下是有jni方法的，这里就是有个疑问，同一个native方法可以重复注册么，还是说这是jni hook的一种实现方式？<br><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/35.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/36.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/37.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/38.png"><img src="/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/39.png"></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2015/06/30/LBE%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/" data-id="cl4bh8h7h0006p8w137c48350" data-title="LBE主动防御逆向" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%86%E5%90%91/" rel="tag">逆向</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-360通讯录网络加密协议分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2015-06-04T05:33:32.000Z" itemprop="datePublished">2015-06-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/">360通讯录网络加密协议分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="分析过程记录"><a href="#分析过程记录" class="headerlink" title="分析过程记录"></a>分析过程记录</h2><p>通过检索关键字，在Java层定位出获取密钥所在的代码段：<br><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/1.png" alt="调Native层获取密钥"><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/2.png" alt="调Native层获取密钥">对libmobilesafe360-jni-530.2.so进行分析，发现导出表下只有1个JNI_OnLoad方法。这里实际是完成了本地函数的注册，其中R2寄存器的值是指向JNINativeMethod结构体的指针。以getInt方法为例，这个native方法对应sub_2A538本地函数。<br><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/3.png" alt="jni注册本地函数"><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/4.png" alt="jni注册本地函数"><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/5.png" alt="对应的本地函数">通过so动态调试的手段，解密”70&gt;@|:CF0z€.97:M0z|ovyrMN6marisa9ExceptionE”字符串获取对应密钥”*#13o-69”。同理，获取其他密钥。  其中，sKey3是用来加密联网上传的参数的，sKey1、sKey2则是用来加密上传的数据部分。。<br><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/6.png" alt="动态调试"><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/7.png" alt="动态调试"></p>
<table>
<thead>
<tr>
<th>DES密钥</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>sKey1</td>
<td>*#13o-69</td>
</tr>
<tr>
<td>sKey2</td>
<td>#ms!,*-@</td>
</tr>
<tr>
<td>sKey3</td>
<td>#mobile@</td>
</tr>
</tbody></table>
<p>联网上传的数据保存在com&#x2F;qihoo360&#x2F;contacts&#x2F;backup&#x2F;http&#x2F;HttpHandler;-&gt;mPostData变量中，追踪该数据的写入来源，中间用到了较多的接口引用，最终可以定位到abm类下的p方法，其中data数据结构所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Struct mPostData&#123;</span><br><span class="line"> U2        <span class="number">1</span></span><br><span class="line"> U2        type</span><br><span class="line"> U4        length</span><br><span class="line"> Unknown   data</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/8.png"><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/9.png"><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/10.png"><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/11.png">抽取上传的数据部分中的数据段部分，这里使用的DES加密算法。需要注意的是，这里的密钥会根据实际传入的布尔类型参数来决定是sKey1还是sKey2。<br><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/12.png">这里自己动手实现一个简单的DES解密算法，前后用sKey1、sKey2来进行解密操作。然后在这个过程中，发现当sKey2作为密钥时，解密后文件均存在固定的文件头，这里怀疑是一个特殊的魔术字，简单查阅了相关资料后，发现其是一个gzip格式的压缩文件，直接解压即可拿到上传数据。。<br><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/13.png"><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/14.png"><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/15.png"><img src="/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/16.png" alt="代码中对应的压缩代码"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2015/06/04/360%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BD%91%E7%BB%9C%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" data-id="cl4bh8h790000p8w1d3323iml" data-title="360通讯录网络加密协议分析" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%86%E5%90%91/" rel="tag">逆向</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ELF-Hook总结与代码实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2015/04/28/ELF-Hook%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2015-04-28T02:07:12.000Z" itemprop="datePublished">2015-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2015/04/28/ELF-Hook%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">ELF Hook总结与代码实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是Hook"><a href="#什么是Hook" class="headerlink" title="什么是Hook"></a>什么是Hook</h2><p>Hook，中文又译为“挂钩”或“钩子”。这里可以首先从字面上做了解，钩子是干什么的呢？日常生活中，我们的钩子是用来钩住某种东西的，比如说，鱼钩是用来钓鱼的，一旦鱼咬了钩，钩子就一直钩住鱼了，任凭鱼在水里怎么游，也逃不出鱼钩的控制。同样的，Android、IOS中的钩子Hook也是用来钩东西的，比较抽象的是它是用来钩函数或者变量的。举个例子，Hook钩子钩住键盘事件相关的函数，那么当有任何相应的键盘操作时，通过Hook就能知道用户都输入了些什么，多么形象啊，把老鼠Mouse钩住了，不管你干什么，都逃不过我钩子Hook的手掌心。</p>
<h2 id="Native-Hook"><a href="#Native-Hook" class="headerlink" title="Native Hook"></a>Native Hook</h2><p>掌握ELF Hook，有必要先了解下ELF文件格式，特别是对于符号表、GOT（全局偏移表）、PLT（过程链接表）、重定位表需要有个清晰的认识。至于这部分在之前的博文中就已做了详细介绍。。</p>
<h3 id="Hook-方式"><a href="#Hook-方式" class="headerlink" title="Hook 方式"></a>Hook 方式</h3><p>So的Hook手法大体来说，一共有3种方式：导入表、导出表及Inline Hook。</p>
<h4 id="导入表Hook"><a href="#导入表Hook" class="headerlink" title="导入表Hook"></a>导入表Hook</h4><p>前面已经提到过“.rel.dyn”和“.rel.plt”两个段中分别保存了该模块所需要导入的变量、函数符号以及其所在模块等信息，而“.got”和“.got.plt”则是保存着这些变量和函数的真正地址。所以，导入表hook的原理主要就是替换.GOT表中外部函数地址（还有一部分被保存在data数据段，比如使用全局函数指针调用外部函数时）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hook rel.plt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">plt_hook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* selfso,<span class="type">const</span> <span class="type">char</span>* funcName, <span class="type">void</span>* realFunc, <span class="type">void</span>** orgFunc)</span></span>&#123;</span><br><span class="line">    <span class="type">void</span>* handle  = <span class="built_in">dlopen</span>(selfso, RTLD_GLOBAL);</span><br><span class="line">    <span class="keyword">if</span>(!handle)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    soinfo* si = (soinfo*)handle;</span><br><span class="line">    Elf32_Sym* symtab = si-&gt;symtab;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* strtab = si-&gt;strtab;</span><br><span class="line">    Elf32_Rel* rel = si-&gt;plt_rel;</span><br><span class="line">    <span class="type">unsigned</span> count = si-&gt;plt_rel_count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGW</span>(<span class="string">&quot;realFunc:0x%08X&quot;</span>,realFunc);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> idx = <span class="number">0</span>; idx &lt; count; idx++)&#123;<span class="comment">//外部依赖函数在rel_plt中</span></span><br><span class="line">        <span class="type">unsigned</span> type = <span class="built_in">ELF32_R_TYPE</span>(rel-&gt;r_info);</span><br><span class="line">        <span class="type">unsigned</span> sym = <span class="built_in">ELF32_R_SYM</span>(rel-&gt;r_info);</span><br><span class="line">        <span class="type">unsigned</span> reloc = (<span class="type">unsigned</span>)(rel-&gt;r_offset + si-&gt;base);</span><br><span class="line">        <span class="keyword">if</span>(*((<span class="type">unsigned</span> <span class="type">int</span>*)reloc) == (<span class="type">unsigned</span> <span class="type">int</span>)realFunc)&#123;</span><br><span class="line">            <span class="built_in">LOGW</span>(<span class="string">&quot;addr had been replace.&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>* sym_name = (<span class="type">char</span>*)(strtab + symtab[sym].st_name);</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="string">&quot;sym_name:%s, reloc_addr = %p&quot;</span>,sym_name,reloc - (si-&gt;base));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sym_name, funcName)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">LOGD</span>(<span class="string">&quot;found %s in plt_rel&quot;</span>,funcName);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">replaceFunc</span>((<span class="type">void</span>*)reloc,realFunc,orgFunc))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rel++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">LOGD</span>(<span class="string">&quot;not find :%s in plt_rel&quot;</span>,funcName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dlclose</span>(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体思路为：当用dlopen打开一个so时，实际返回的是一个soinfo结构体，这里已经包含了so的相关信息。之后，直接根据“.rel.plt”重定位表中的offset定位到“.got.plt”，进行修改替换即可。<br>如果细心观察的话，就会注意到上面的代码是有所遗漏的。它仅针对了直接调用外部函数的情况，当使用全局函数指针调用外部函数时（重定位类型为R_ARM_ABS32），用的是”.rel.dyn”重定位表，其下的offset会定位到data段，数据段的该地址下保存着实际外部函数的真正地址。对应实现上，只需补个重定位类型的判断，其余代码都是类似的，将”.rel.plt”换成”.rel.dyn”即可，有兴趣的同学可以自己动手试试。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>导入表 HOOK的本质其实就是”改自身”，即修改当前应用进程下的Got表中外部符号地址。所以它的功能是很有限的，不会影响到其他进程。此外，对于通过dlopen 动态获得并调用外部符号这种情形是无效的。<br>特点：即时生效。因为是直接改的Got表、修改了外部函数的调用地址，所以在进行测试时是hook后可直接看到效果的。。</p>
<h4 id="导出表Hook"><a href="#导出表Hook" class="headerlink" title="导出表Hook"></a>导出表Hook</h4><p>ELF文件中的符号表有说明该符号为导入符号还是导出符号，这点在linker.c源码中可以看到。linker将so加载到内存后，在最后阶段是有对符号进行重定位的。在重定位过程中，如果发现符号为外部符号，会去解析相应的依赖库，获取外部符号的地址。所以，导出表Hook的原理就是修改要hook的函数所在so中的符号表中的值，并对其进行替换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hook symtab</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sym_hook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* hookso,<span class="type">const</span> <span class="type">char</span>* funcName, <span class="type">void</span>* realFunc, <span class="type">void</span>** orgFunc)</span></span>&#123;</span><br><span class="line">    <span class="type">void</span>* handle  = <span class="built_in">dlopen</span>(hookso, RTLD_GLOBAL);</span><br><span class="line">    <span class="keyword">if</span>(!handle)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    soinfo* si = (soinfo*)handle;</span><br><span class="line">    Elf32_Sym* symtab = si-&gt;symtab;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* strtab = si-&gt;strtab;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> idx = <span class="number">0</span>; idx &lt; si-&gt;nchain; idx++)&#123;<span class="comment">//自定义函数在symtab中</span></span><br><span class="line">        <span class="type">char</span>* sym_name = (<span class="type">char</span>*)(strtab + symtab[idx].st_name);</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="string">&quot;sym_name in exports:%s, func_addr:0x%08X&quot;</span>,sym_name,symtab[idx].st_value);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sym_name, funcName)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">LOGD</span>(<span class="string">&quot;found %s in exports&quot;</span>,funcName);</span><br><span class="line">            <span class="type">void</span>* funcAddr = (<span class="type">void</span>*)(symtab[idx].st_value + si-&gt;base);</span><br><span class="line">            <span class="keyword">if</span>((&amp;symtab[idx])-&gt;st_value == (Elf32_Addr)((<span class="type">unsigned</span>)realFunc-(si-&gt;base)))&#123;</span><br><span class="line">                <span class="built_in">LOGW</span>(<span class="string">&quot;addr had been replace.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *orgFunc = funcAddr;</span><br><span class="line">            <span class="built_in">LOGW</span>(<span class="string">&quot;base_addr:0x%08X&quot;</span>,si-&gt;base);</span><br><span class="line">            <span class="built_in">LOGW</span>(<span class="string">&quot;OldFun:0x%08X&quot;</span>,*orgFunc);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">modifyMemAccess</span>(&amp;symtab[idx], PROT_EXEC|PROT_READ|PROT_WRITE))&#123;</span><br><span class="line">                <span class="built_in">LOGE</span>(<span class="string">&quot;[-] modifymemAccess fails, error %s.&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            (&amp;symtab[idx])-&gt;st_value = (Elf32_Addr)((<span class="type">unsigned</span>)realFunc - (si-&gt;base));</span><br><span class="line">            <span class="built_in">clearCache</span>(symtab, <span class="built_in">getpagesize</span>());</span><br><span class="line">            <span class="built_in">LOGW</span>(<span class="string">&quot;st_value:0x%08X, NewFun:0x%08X&quot;</span>,symtab[idx].st_value,realFunc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dlclose</span>(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体思路为：用dlopen打开一个so，根据返回的soinfo结构体定位到符号表。在符号表中查找要hook的函数名，并修改该符号的st_value值为NewFunc – BaseAddr（st_value保存的是偏移地址）</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>导出表Hook和导入表Hook的代码实现其实比较类似，本质都是修改函数地址，但却能起到较好的效果。因为它是直接改的要hook的函数所在so中的符号表，其他库要调用该so中的方法，都会从它的符号表下进行引用，并填充到自身的Got表下，所以能够起到一次Hook，永久替换的效果。当然，其拦截效果还是不如inline这种方式。不过由于inline hook会受到函数字节数的轻微限制，导出表hook也可视为一种对Inline的补充。此外，导出表Hook只能Hook导出的符号，对偏移函数没有办法。<br>特点：不能即时生效。因为改的是符号表，当前运行的程序已经加载完成，调用外部函数时，是直接走的Got。所以进行测试时，在hook完成后，还需要再loadlibrary一次，让修改过的符号重新导入到Got表。说到这里，其实也能dlopen、dlsym来进行测试，让dlsym来检验是否已修改目标的st_value。。</p>
<h4 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h4><p>Inline hook其实就是直接修改函数指令，对代码的调用流程进行替换，它的基本流程如下所示：<br><img src="/2015/04/28/ELF-Hook%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/1.png" alt="Inline Hook">这部分的代码实现，个人是直接参考的<a target="_blank" rel="noopener" href="https://github.com/crmulliner/adbi%E8%BF%99%E4%B8%AA%E5%BC%80%E6%BA%90%E7%9A%84hook">https://github.com/crmulliner/adbi这个开源的hook</a> 框架。不过，它有个bug，注意到这个问题是在<a target="_blank" rel="noopener" href="http://drops.wooyun.org/tips/5409%E6%94%BE%E5%87%BA%E9%98%BF%E9%87%8C%E4%B8%BE%E5%8A%9E%E7%9A%84%E5%AE%89%E5%85%A8%E6%8C%91%E6%88%98%E8%B5%9B%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E6%97%B6%EF%BC%88%E5%85%B6%E5%AE%9E%E4%BA%86%E8%A7%A3%E5%88%B0adbi">http://drops.wooyun.org/tips/5409放出阿里举办的安全挑战赛的解题思路时（其实了解到adbi</a> hook也是这个时间）。<br><img src="/2015/04/28/ELF-Hook%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/2.png" alt="阿里安全挑战赛">对adbi hook源码中的这一部分进行修改后，再来分析下它的实现原理。先看看hook.h头文件中定义的hook_t结构体，具体结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hook_t</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> jump[<span class="number">3</span>];         <span class="comment">//要修改的Hook指令(ARM)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> store[<span class="number">3</span>];        <span class="comment">//被修改的原指令(ARM)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jumpt[<span class="number">20</span>];      <span class="comment">//要修改的Hook指令(Thumb)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> storet[<span class="number">20</span>];     <span class="comment">//被修改的原指令(Thumb)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> orig;            <span class="comment">//被Hook的函数地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> patch;           <span class="comment">//Hook的函数地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thumb;          <span class="comment">//表明要Hook函数所使用的指令集，1为Thumb，0为Arm</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> name[<span class="number">128</span>];      <span class="comment">//被Hook的函数名</span></span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以注意到，inline hook是有判断原函数所使用的指令模式的。这是因为Arm处理器支持两种指令集，一个基本的Arm指令集，另一个是Thumb指令集。而hook的函数有可能是被编译成Arm指令集的，也有可能是被编译成Thumb指令集的。若一个用Arm指令集编译的函数被用Thumb指令集的指令给修改了，那必定会崩溃，反之亦然。。<br>那么要如何判断hook的函数用的是哪种指令集呢？代码中是这么判断的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用Arm指令集的情况 */</span>  </span><br><span class="line"><span class="keyword">if</span> (addr % <span class="number">4</span> == <span class="number">0</span>) &#123;  </span><br><span class="line">    ......  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/* 使用Thumb指令集的情况 */</span>  </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">    ......  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这是因为Arm与Thumb之间的状态切换是通过专用的转移交换指令BX来实现。BX指令以通用寄存器（R0~R15）为操作数，通过拷贝Rn到PC实现绝对跳转。BX利用Rn寄存器中目的地址值的最后一位来判断跳转后的状态，如果为“1”表示跳转到Thumb指令集的函数中，如果为“0”则表示跳转到Arm指令集的函数中。而Arm指令集的每条指令是32位，即4个字节，也就是说 Arm指令的地址肯定是4的倍数，最后两位必定为“00”。所以，可直接将从符号表中获得的调用地址对4求余，看是否为0来判断要hook的函数用的是Arm指令集还是Thumb指令集。<br>需要说明的是，这里的调用地址与函数的映射地址是不一样的概念。所谓调用地址，是从ELF文件中的符号表里获得的。但是Thumb指令集是16位的，也就意味着其不可能映射到奇数地址上，映射地址的最后一位肯定不为“1”。关于这点，还是拿前面用来分析ELF文件格式的例子so来进行说明：<br><img src="/2015/04/28/ELF-Hook%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/3.png" alt="ELF文件格式例子so">以registerNatives方法为例，其符号值为0x00000dad，最后一位是“1”，表示其是用Thumb指令集编译的。这个函数在内存中的映射地址为0x400D1DAC - 0x400D1000 &#x3D; 0x00000DAC，最后一位是“0”。通过这个比较可以看出，编译器如果用Thumb指令编译了一个函数，会自动将该函数的符号地址设置为“真正映射地址 -1”，这样可以实现无缝的Thumb指令集函数与Arm指令集代码混编。<br><img src="/2015/04/28/ELF-Hook%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/4.png" alt="so动态调试">再回来看下对Arm的处理，先将hook函数和要被hook的函数地址保留下来。然后生成hook代码，只用到了3 * 4 &#x3D; 12个字节。其中，第一个字节是代码“LDR pc, [pc, #0]”，由于pc寄存器读出的值实际上是当前指令地址加8（预取2条指令，2*4），所以这里是把jump[2]的值加载进pc寄存器，而jump[2]处保存的是hook函数的地址。因此，jump[0]到jump[3]实际上保存的是跳转到hook函数的指令。然后，将原函数的前3 * 4个字节保存下来，方便以后做恢复。最后，将跳转指令写入到被hook函数（原函数）的前12个字节。这样，当要调用被hook函数的时候，实际执行的指令就是跳转到hook函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (addr % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;ARM using 0x%x\n&quot;</span>, hook_arm)</span><br><span class="line">    h-&gt;thumb = <span class="number">0</span>;</span><br><span class="line">    h-&gt;patch = (<span class="type">unsigned</span> <span class="type">int</span>)hook_arm;</span><br><span class="line">    h-&gt;orig = addr;</span><br><span class="line">    h-&gt;jump[<span class="number">0</span>] = <span class="number">0xe59ff000</span>; <span class="comment">// LDR pc, [pc, #0]</span></span><br><span class="line">    h-&gt;jump[<span class="number">1</span>] = h-&gt;patch;</span><br><span class="line">    h-&gt;jump[<span class="number">2</span>] = h-&gt;patch;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        h-&gt;store[i] = ((<span class="type">int</span>*)h-&gt;orig)[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        ((<span class="type">int</span>*)h-&gt;orig)[i] = h-&gt;jump[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对Thumb指令的处理，与对Arm的处理稍有不同，是通过pop指令来修改PC寄存器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>)hook_thumb % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">&quot;warning hook is not thumb 0x%x\n&quot;</span>, hook_thumb)</span><br><span class="line">    h-&gt;thumb = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;THUMB using 0x%x\n&quot;</span>, hook_thumb)</span><br><span class="line">    h-&gt;patch = (<span class="type">unsigned</span> <span class="type">int</span>)hook_thumb;</span><br><span class="line">    h-&gt;orig = addr; </span><br><span class="line">    h-&gt;jumpt[<span class="number">1</span>] = <span class="number">0xb4</span>;</span><br><span class="line">    h-&gt;jumpt[<span class="number">0</span>] = <span class="number">0x60</span>; <span class="comment">// push &#123;r5,r6&#125;</span></span><br><span class="line">    h-&gt;jumpt[<span class="number">3</span>] = <span class="number">0xa5</span>;</span><br><span class="line">    h-&gt;jumpt[<span class="number">2</span>] = <span class="number">0x03</span>; <span class="comment">// add r5, pc, #12</span></span><br><span class="line">    h-&gt;jumpt[<span class="number">5</span>] = <span class="number">0x68</span>;</span><br><span class="line">    h-&gt;jumpt[<span class="number">4</span>] = <span class="number">0x2d</span>; <span class="comment">// ldr r5, [r5]</span></span><br><span class="line">    h-&gt;jumpt[<span class="number">7</span>] = <span class="number">0xb0</span>;</span><br><span class="line">    h-&gt;jumpt[<span class="number">6</span>] = <span class="number">0x02</span>; <span class="comment">// add sp,sp,#8</span></span><br><span class="line">    h-&gt;jumpt[<span class="number">9</span>] = <span class="number">0xb4</span>;</span><br><span class="line">    h-&gt;jumpt[<span class="number">8</span>] = <span class="number">0x20</span>; <span class="comment">// push &#123;r5&#125;</span></span><br><span class="line">    h-&gt;jumpt[<span class="number">11</span>] = <span class="number">0xb0</span>;</span><br><span class="line">    h-&gt;jumpt[<span class="number">10</span>] = <span class="number">0x81</span>; <span class="comment">// sub sp,sp,#4</span></span><br><span class="line">    h-&gt;jumpt[<span class="number">13</span>] = <span class="number">0xbd</span>;</span><br><span class="line">    h-&gt;jumpt[<span class="number">12</span>] = <span class="number">0x20</span>; <span class="comment">// pop &#123;r5, pc&#125;</span></span><br><span class="line">    h-&gt;jumpt[<span class="number">15</span>] = <span class="number">0x46</span>;</span><br><span class="line">    h-&gt;jumpt[<span class="number">14</span>] = <span class="number">0xaf</span>; <span class="comment">// mov pc, r5 ; just to pad to 4 byte boundary</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;h-&gt;jumpt[<span class="number">16</span>], (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;h-&gt;patch, <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> orig = addr - <span class="number">1</span>; <span class="comment">// sub 1 to get real address</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        h-&gt;storet[i] = ((<span class="type">unsigned</span> <span class="type">char</span>*)orig)[i];</span><br><span class="line">        <span class="comment">//log(&quot;%0.2x &quot;, h-&gt;storet[i])</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//log(&quot;\n&quot;)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">char</span>*)orig)[i] = h-&gt;jumpt[i];</span><br><span class="line">        <span class="comment">//log(&quot;%0.2x &quot;, ((unsigned char*)orig)[i])</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，压栈r5、r6寄存器，将r5压栈是因为后面修改了r5寄存器的值，压栈方便以后做恢复，而将r6寄存器压栈则是为了要保留一个位置。接着，将PC寄存器的值加上12赋值给r5。然后，读出的PC寄存器的值是当前指令地址加上4（预取2条指令，2*2）。于是，r5寄存器的值指向的应该是jumpt[18]，但果真如此么？jumpt[16]中存放着hook函数地址，如果要做跳转的话，应该是指向jumpt[16]才对。在翻看Thumb&amp;ARM指令文档后，才明白中间缘由。主要就是，thmub模式下的”ADD Rd, PC, #立即数”这条语句有点特殊：1、加上的立即数必须是4的倍数；2、加完后需要与0xFFFFFFFc进行与运算、将地址的最后2位清零。也就是，(2 + 4)&amp;0xFFFFFFFc 等于4，4再加上12指向jumpt[16]。<br><img src="/2015/04/28/ELF-Hook%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/5.png" alt="arm指令汇编文档"><img src="/2015/04/28/ELF-Hook%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/6.png" alt="arm指令汇编文档">再下面的指令”ldr r5, [r5]” 就是将保存在jumpt[16]处的hook函数地址加载到r5寄存器中，后面则是一些栈操作，大致的流程图如下：<br><img src="/2015/04/28/ELF-Hook%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/7.png" alt="指令栈操作">所以，下面的”pop {r5, pc}”指令刚好可以完成恢复r5寄存器并且修改PC寄存器，从而跳转到hook函数的操作。接下来的指令（jumpt[14]到jumpt[15]）其实是多余的了，根本不会执行到，只是因为前面的add指令只能加4的倍数。另外，还有一点不同的是，因为被hook函数是Thumb指令集，所以其真正的内存映射地址是其符号地址减1。<br>经过上面的处理，被hook函数的前几条指令已经被修改成跳转到hook函数的指令了，接下来被hook函数如果被调用到了，实际上就会跳转到指定的hook函数上去。</p>
<h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>Inline Hook是直接改的函数运行代码，能够即时生效，且拦截性高。缺点是实现较为复杂，与硬件平台相关。另外inline的替换字节为12到16个字节左右，当函数比较简短的时候，会无法发挥效果。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2015/04/28/ELF-Hook%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" data-id="cl4bh8h7g0004p8w12ljm6g72" data-title="ELF Hook总结与代码实现" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/" rel="tag">ELF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浅谈ELF可执行文件的启动流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2015/04/17/%E6%B5%85%E8%B0%88ELF%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2015-04-17T14:41:39.000Z" itemprop="datePublished">2015-04-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2015/04/17/%E6%B5%85%E8%B0%88ELF%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">浅谈ELF可执行文件的启动流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>无论是动态链接还是静态链接的原生程序，在链接阶段都会传入一个链接脚本。根据链接时指定参数的不同，所传入的链接脚本也不一样。在 NDK 目录下检索 ldscripts，所有的链接脚本都在该路径中。默认情况下，会传入armelf_linux_eabi.x脚本文件。<br>![链接脚本][image-1]在默认的链接脚本中，声明了可执行文件在进程中的基地址为0x00008000，并将”_start”指定为入口函数。这里，我们可以动手用IDA调试一个原生程序进行对比确认。。<br>![IDA动态调试][image-2]其中，_start函数定义在Android源码路径中的&#x2F;bionic&#x2F;libc&#x2F;arch-arm&#x2F;bionic&#x2F;Crtbegin.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../bionic/libc_init_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__ ((section (<span class="string">&quot;.preinit_array&quot;</span>)))</span><br><span class="line"><span class="type">void</span> (*__PREINIT_ARRAY__)(<span class="type">void</span>) = (<span class="type">void</span> (*)(<span class="type">void</span>)) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">__attribute__ ((section (<span class="string">&quot;.init_array&quot;</span>)))</span><br><span class="line"><span class="type">void</span> (*__INIT_ARRAY__)(<span class="type">void</span>) = (<span class="type">void</span> (*)(<span class="type">void</span>)) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">__attribute__ ((section (<span class="string">&quot;.fini_array&quot;</span>)))</span><br><span class="line"><span class="type">void</span> (*__FINI_ARRAY__)(<span class="type">void</span>) = (<span class="type">void</span> (*)(<span class="type">void</span>)) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">__LIBC_HIDDEN__ <span class="type">void</span> _start() &#123;</span><br><span class="line">  <span class="type">structors_array_t</span> <span class="built_in">array</span>;</span><br><span class="line">  <span class="built_in">array</span>.preinit_array = &amp;__PREINIT_ARRAY__;</span><br><span class="line">  <span class="built_in">array</span>.init_array = &amp;__INIT_ARRAY__;</span><br><span class="line">  <span class="built_in">array</span>.fini_array = &amp;__FINI_ARRAY__;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* raw_args = (<span class="type">void</span>*) ((<span class="type">uintptr_t</span>) __builtin_frame_address(<span class="number">0</span>) + <span class="keyword">sizeof</span>(<span class="type">void</span>*));</span><br><span class="line">  __libc_init(raw_args, <span class="literal">NULL</span>, &amp;main, &amp;<span class="built_in">array</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;__dso_handle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;atexit.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>_start方法中调用了_libc_init，并将main函数的地址和指向preinit_array、init_array、fini_array数组的指针作为参数传入。再来看下_libc_init的实现，这部分在Android源码中的路径为&#x2F;bionic&#x2F;libc&#x2F;bionic&#x2F;libc_init_static.cpp及&#x2F;bionic&#x2F;libc&#x2F;bionic&#x2F;libc_init_dynamic.cpp，分别对应静态链接和动态链接的程序。<br>这里，让我们先看下静态链接的部分。在__libc_init中会先进行一些初始化工作，再调用preinit_array、init_array，最后调用由参数slingshot传入的main函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__noreturn <span class="type">void</span> __libc_init(<span class="type">void</span>* raw_args,</span><br><span class="line">                            <span class="built_in">void</span> (*onexit)(<span class="type">void</span>),</span><br><span class="line">                            <span class="built_in">int</span> (*slingshot)(<span class="type">int</span>, <span class="type">char</span>**, <span class="type">char</span>**),</span><br><span class="line">                            <span class="type">structors_array_t</span> <span class="type">const</span> * <span class="type">const</span> structors) &#123;</span><br><span class="line">  <span class="function">KernelArgumentBlock <span class="title">args</span><span class="params">(raw_args)</span></span>;</span><br><span class="line">  __libc_init_tls(args);</span><br><span class="line">  __libc_init_common(args);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">apply_gnu_relro</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Several Linux ABIs don&#x27;t pass the onexit pointer, and the ones that</span></span><br><span class="line">  <span class="comment">// do never use it.  Therefore, we ignore it.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">call_array</span>(structors-&gt;preinit_array);</span><br><span class="line">  <span class="built_in">call_array</span>(structors-&gt;init_array);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The executable may have its own destructors listed in its .fini_array</span></span><br><span class="line">  <span class="comment">// so we need to ensure that these are called when the program exits</span></span><br><span class="line">  <span class="comment">// normally.</span></span><br><span class="line">  <span class="keyword">if</span> (structors-&gt;fini_array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    __cxa_atexit(__libc_fini,structors-&gt;fini_array,<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="built_in">slingshot</span>(args.argc, args.argv, args.envp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态链接的程序在启动时不需要额外加载其他的动态库，不过这类程序相对较少，Android系统已知的有init、adbd、linker等程序。实际我们遇到的大多数可执行文件都是动态链接的，它的情况较上面的描述稍有不同。动态链接的程序在运行前还需要做一些初始化工作，如运行所依赖的动态库需要先被载入内存。当执行动态链接的程序时，系统会解析该ELF文件，并找到.interp段中所保存的程序解释器，默认是”&#x2F;system&#x2F;bin&#x2F;linker”。然后先执行linker，linker会加载该程序的所依赖的一系列so，最后再调用该可执行程序。<br>值得注意的是，linker的入口函数_start并不在Crtbegin.c中。在源码&#x2F;bionic&#x2F;linker&#x2F;Android.mk文件中，linker指定了自己的启动函数所在路径，即&#x2F;bionic&#x2F;linker&#x2F;arch&#x2F;arm&#x2F;begin.S</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line">    .align 4</span><br><span class="line">    .type _start,#function</span><br><span class="line">    .globl _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov r0, sp</span><br><span class="line">    mov r1, #0</span><br><span class="line">    bl  __linker_init</span><br><span class="line"></span><br><span class="line">    /* linker init returns the _entry address in the main image */</span><br><span class="line">    mov pc, r0</span><br><span class="line"></span><br><span class="line">    .section .ctors, &quot;wa&quot;</span><br><span class="line">    .globl __CTOR_LIST__</span><br><span class="line">__CTOR_LIST__:</span><br><span class="line">    .long -1</span><br></pre></td></tr></table></figure>
<p>首先，调用_linker_init函数完成linker的”自举”，并进行一些初始化工作，最后会返回原native程序的入口函数地址（根据native程序的文件头获取）。<br>至于”mov pc, r0”这条语句，它的作用则是跳转到native程序的入口函数(_start)去执行。<br>再往后的调用过程与之前已经描述过的一样，都是_start调用_libc_init。此外，前面还提到过，动态链接程序的__libc_init是定义在libc_init_dynamic.cpp文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function is called from the executable&#x27;s _start entry point</span></span><br><span class="line"><span class="comment">// (see arch-$ARCH/bionic/crtbegin_dynamic.S), which is itself</span></span><br><span class="line"><span class="comment">// called by the dynamic linker after it has loaded all shared</span></span><br><span class="line"><span class="comment">// libraries the executable depends on.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that the dynamic linker has also run all constructors in the</span></span><br><span class="line"><span class="comment">// executable at this point.</span></span><br><span class="line">__noreturn <span class="type">void</span> __libc_init(<span class="type">void</span>* raw_args,</span><br><span class="line">                            <span class="built_in">void</span> (*onexit)(<span class="type">void</span>),</span><br><span class="line">                            <span class="built_in">int</span> (*slingshot)(<span class="type">int</span>, <span class="type">char</span>**, <span class="type">char</span>**),</span><br><span class="line">                            <span class="type">structors_array_t</span> <span class="type">const</span> * <span class="type">const</span> structors) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">KernelArgumentBlock <span class="title">args</span><span class="params">(raw_args)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Several Linux ABIs don&#x27;t pass the onexit pointer, and the ones that</span></span><br><span class="line">  <span class="comment">// do never use it.  Therefore, we ignore it.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The executable may have its own destructors listed in its .fini_array</span></span><br><span class="line">  <span class="comment">// so we need to ensure that these are called when the program exits</span></span><br><span class="line">  <span class="comment">// normally.</span></span><br><span class="line">  <span class="keyword">if</span> (structors-&gt;fini_array) &#123;</span><br><span class="line">    __cxa_atexit(__libc_fini,structors-&gt;fini_array,<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="built_in">slingshot</span>(args.argc, args.argv, args.envp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，这段代码比静态链接程序的__libc_init还要简单些，这是因为一些初始化工作由linker完成了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是静态链接还是动态链接，native程序的入口函数都是_start。里面存在main方法和执向init_array、fini_array等数组的指针，它们对应初始化函数和析构函数。其中，动态链接的程序在执行_start之前，会先由linker加载所需的依赖库，并进行一些初始化工作。此外，可执行文件在进程中的基地址为0x00008000，关于这点可以做下备忘。。</p>
<p>[image-1]:	浅谈ELF可执行文件的启动流程&#x2F;1.png<br>[image-2]:	浅谈ELF可执行文件的启动流程&#x2F;2.png</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2015/04/17/%E6%B5%85%E8%B0%88ELF%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" data-id="cl4bh8h7p000tp8w1c0eleoac" data-title="浅谈ELF可执行文件的启动流程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/" rel="tag">ELF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-细说So动态库的加载流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2015-04-09T05:52:18.000Z" itemprop="datePublished">2015-04-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">细说So动态库的加载流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="dlopen之内存装载"><a href="#dlopen之内存装载" class="headerlink" title="dlopen之内存装载"></a>dlopen之内存装载</h2><p>dlopen用来打开一个动态链接库，并将其装入内存。它的定义在Android源码中的路径为&#x2F;bionic&#x2F;linker&#x2F;dlfcn.cpp，执行流程如下：<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/so.jpg" alt="dlopen执行流程">其核心代码在do_dlopen中实现，根据传入的路径或文件名去查找一个动态库，并执行该动态链接库的初始化代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> flags)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedPthreadMutexLocker <span class="title">locker</span><span class="params">(&amp;gDlMutex)</span></span>;</span><br><span class="line">  soinfo* result = <span class="built_in">do_dlopen</span>(filename, flags);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    __bionic_format_dlerror(<span class="string">&quot;dlopen failed&quot;</span>, <span class="built_in">linker_get_error_buffer</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">soinfo* <span class="title">do_dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((flags &amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid flags to dlopen: %x&quot;</span>, flags);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set_soinfo_pool_protection</span>(PROT_READ | PROT_WRITE);</span><br><span class="line">  soinfo* si = <span class="built_in">find_library</span>(name);</span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    si-&gt;<span class="built_in">CallConstructors</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set_soinfo_pool_protection</span>(PROT_READ);</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看find_library这个方法，它会先在solist（已经加载的动态链接库链表）里进行查找，如果找到了就返回对应的soinfo结构体指针。否则，就调用load_library进行加载。然后，调用soinfo_link_image方法，根据soinfo结构体解析相应的Section。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> soinfo *<span class="title">find_loaded_library</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    soinfo *si;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *bname;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> don&#x27;t use basename only for determining libraries</span></span><br><span class="line">    <span class="comment">// http://code.google.com/p/android/issues/detail?id=6670</span></span><br><span class="line"></span><br><span class="line">    bname = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    bname = bname ? bname + <span class="number">1</span> : name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (si = solist; si != <span class="literal">NULL</span>; si = si-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(bname, si-&gt;name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> soinfo* <span class="title">find_library_internal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> somain;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  soinfo* si = <span class="built_in">find_loaded_library</span>(name);</span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (si-&gt;flags &amp; FLAG_LINKED) &#123;</span><br><span class="line">      <span class="keyword">return</span> si;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;OOPS: recursive link to \&quot;%s\&quot;&quot;</span>, si-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;[ &#x27;%s&#x27; has not been loaded yet.  Locating...]&quot;</span>, name);</span><br><span class="line">  si = <span class="built_in">load_library</span>(name);</span><br><span class="line">  <span class="keyword">if</span> (si == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At this point we know that whatever is loaded @ base is a valid ELF</span></span><br><span class="line">  <span class="comment">// shared library whose segments are properly mapped in.</span></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;[ init_library base=0x%08x sz=0x%08x name=&#x27;%s&#x27; ]&quot;</span>,</span><br><span class="line">        si-&gt;base, si-&gt;size, si-&gt;name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">soinfo_link_image</span>(si)) &#123;</span><br><span class="line">    <span class="built_in">munmap</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(si-&gt;base), si-&gt;size);</span><br><span class="line">    <span class="built_in">soinfo_free</span>(si);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> soinfo* <span class="title">find_library</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">  soinfo* si = <span class="built_in">find_library_internal</span>(name);</span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    si-&gt;ref_count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load_library调用open_library打开一个动态链接库，返回一个句柄，将其与共享库所在的路径作为参数，对ElfReader进行初始化。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/7.png" alt="dlopen调用链"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/8.png" alt="dlopen调用链">ElfReader作用域中的Load函数，会执行以下操作：  </p>
<ol>
<li>读取并校验ELF文件头</li>
<li>读ELF程序头并映射至内存</li>
<li>将Load Segment加载进内存</li>
<li>在内存中找到程序的起始地址<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::Load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ReadElfHeader</span>() &amp;&amp;</span><br><span class="line">         <span class="built_in">VerifyElfHeader</span>() &amp;&amp;</span><br><span class="line">         <span class="built_in">ReadProgramHeader</span>() &amp;&amp;</span><br><span class="line">         <span class="built_in">ReserveAddressSpace</span>() &amp;&amp;</span><br><span class="line">         <span class="built_in">LoadSegments</span>() &amp;&amp;</span><br><span class="line">         <span class="built_in">FindPhdr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadElfHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">ssize_t</span> rc = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">read</span>(fd_, &amp;header_, <span class="built_in">sizeof</span>(header_)));</span><br><span class="line">  <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t read file \&quot;%s\&quot;: %s&quot;</span>, name_, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (rc != <span class="built_in">sizeof</span>(header_)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; is too small to be an ELF executable&quot;</span>, name_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><font color="#006666" size="3" face="黑体">**读ELF文件头**</font></center>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loads the program header table from an ELF file into a read-only private</span></span><br><span class="line"><span class="comment">// anonymous mmap-ed block.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadProgramHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  phdr_num_ = header_.e_phnum;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Like the kernel, we only accept program header tables that</span></span><br><span class="line">  <span class="comment">// are smaller than 64KiB.</span></span><br><span class="line">  <span class="keyword">if</span> (phdr_num_ &lt; <span class="number">1</span> || phdr_num_ &gt; <span class="number">65536</span>/<span class="built_in">sizeof</span>(Elf32_Phdr)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid e_phnum: %d&quot;</span>, name_, phdr_num_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Elf32_Addr page_min = <span class="built_in">PAGE_START</span>(header_.e_phoff);  <span class="comment">//页的起始地址</span></span><br><span class="line">  Elf32_Addr page_max = <span class="built_in">PAGE_END</span>(header_.e_phoff + (phdr_num_ * <span class="built_in">sizeof</span>(Elf32_Phdr)));  <span class="comment">//页的结束地址</span></span><br><span class="line">  Elf32_Addr page_offset = <span class="built_in">PAGE_OFFSET</span>(header_.e_phoff);  <span class="comment">//程序头部在页中的偏移</span></span><br><span class="line"></span><br><span class="line">  phdr_size_ = page_max - page_min;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* mmap_result = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, phdr_size_, PROT_READ, MAP_PRIVATE, fd_, page_min);  <span class="comment">//将程序头映射到内存</span></span><br><span class="line">  <span class="keyword">if</span> (mmap_result == MAP_FAILED) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; phdr mmap failed: %s&quot;</span>, name_, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  phdr_mmap_ = mmap_result;</span><br><span class="line">  phdr_table_ = <span class="built_in">reinterpret_cast</span>&lt;Elf32_Phdr*&gt;(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(mmap_result) + page_offset);  <span class="comment">//程序头表在内存中的地址</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><font color="#006666" size="3" face="黑体">**读ELF程序头，并映射到内存**</font></center>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reserve a virtual address range big enough to hold all loadable</span></span><br><span class="line"><span class="comment">// segments of a program header table. This is done by creating a</span></span><br><span class="line"><span class="comment">// private anonymous mmap() with PROT_NONE.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReserveAddressSpace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Elf32_Addr min_vaddr;</span><br><span class="line">  load_size_ = <span class="built_in">phdr_table_get_load_size</span>(phdr_table_, phdr_num_, &amp;min_vaddr);  <span class="comment">//根据页对齐来计算Load段所占用的大小</span></span><br><span class="line">  <span class="keyword">if</span> (load_size_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has no loadable segments&quot;</span>, name_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(min_vaddr);</span><br><span class="line">  <span class="type">int</span> mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS;  <span class="comment">//匿名私有</span></span><br><span class="line">  <span class="type">void</span>* start = <span class="built_in">mmap</span>(addr, load_size_, PROT_NONE, mmap_flags, <span class="number">-1</span>, <span class="number">0</span>);  <span class="comment">//调用mmap为动态库分配一块内存空间</span></span><br><span class="line">  <span class="keyword">if</span> (start == MAP_FAILED) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t reserve %d bytes of address space for \&quot;%s\&quot;&quot;</span>, load_size_, name_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  load_start_ = start;</span><br><span class="line">  load_bias_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(start) - addr;  <span class="comment">//真实的加载地址与计算出来的（读ELF程序头中的p_vaddr）加载地址之差</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><font color="#006666" size="3" face="黑体">**调用mmap申请一块足够大的内存空间，为后面进行映射Load段的映射做准备**</font></center>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map all loadable segments in process&#x27; address space.</span></span><br><span class="line"><span class="comment">// This assumes you already called phdr_table_reserve_memory to</span></span><br><span class="line"><span class="comment">// reserve the address space range for the library.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> assert assumption.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::LoadSegments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; phdr_num_; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> Elf32_Phdr* phdr = &amp;phdr_table_[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Segment addresses in memory.</span></span><br><span class="line">    Elf32_Addr seg_start = phdr-&gt;p_vaddr + load_bias_;</span><br><span class="line">    Elf32_Addr seg_end   = seg_start + phdr-&gt;p_memsz;</span><br><span class="line"></span><br><span class="line">    Elf32_Addr seg_page_start = <span class="built_in">PAGE_START</span>(seg_start);</span><br><span class="line">    Elf32_Addr seg_page_end   = <span class="built_in">PAGE_END</span>(seg_end);</span><br><span class="line"></span><br><span class="line">    Elf32_Addr seg_file_end   = seg_start + phdr-&gt;p_filesz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// File offsets.</span></span><br><span class="line">    Elf32_Addr file_start = phdr-&gt;p_offset;</span><br><span class="line">    Elf32_Addr file_end   = file_start + phdr-&gt;p_filesz;</span><br><span class="line"></span><br><span class="line">    Elf32_Addr file_page_start = <span class="built_in">PAGE_START</span>(file_start);</span><br><span class="line">    Elf32_Addr file_length = file_end - file_page_start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file_length != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">void</span>* seg_addr = <span class="built_in">mmap</span>((<span class="type">void</span>*)seg_page_start,          <span class="comment">//将Load Segment映射到内存，大小为在ELF文件中所占用的长度</span></span><br><span class="line">                            file_length,</span><br><span class="line">                            <span class="built_in">PFLAGS_TO_PROT</span>(phdr-&gt;p_flags),</span><br><span class="line">                            MAP_FIXED|MAP_PRIVATE,</span><br><span class="line">                            fd_,</span><br><span class="line">                            file_page_start);</span><br><span class="line">      <span class="keyword">if</span> (seg_addr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t map \&quot;%s\&quot; segment %d: %s&quot;</span>, name_, i, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the segment is writable, and does not end on a page boundary,</span></span><br><span class="line">    <span class="comment">// zero-fill it until the page limit.</span></span><br><span class="line">    <span class="keyword">if</span> ((phdr-&gt;p_flags &amp; PF_W) != <span class="number">0</span> &amp;&amp; <span class="built_in">PAGE_OFFSET</span>(seg_file_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span>*)seg_file_end, <span class="number">0</span>, PAGE_SIZE - <span class="built_in">PAGE_OFFSET</span>(seg_file_end));  <span class="comment">//如果这块Segment是可写的，且在内存中的结束地址不在页的边界上，则将后面的数据都填充0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    seg_file_end = <span class="built_in">PAGE_END</span>(seg_file_end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// seg_file_end is now the first page address after the file</span></span><br><span class="line">    <span class="comment">// content. If seg_end is larger, we need to zero anything</span></span><br><span class="line">    <span class="comment">// between them. This is done by using a private anonymous</span></span><br><span class="line">    <span class="comment">// map for all extra pages.</span></span><br><span class="line">    <span class="keyword">if</span> (seg_page_end &gt; seg_file_end) &#123;</span><br><span class="line">      <span class="type">void</span>* zeromap = <span class="built_in">mmap</span>((<span class="type">void</span>*)seg_file_end,                 <span class="comment">//如果seg_end大于它在文件中的长度，则继续为多出的那部分申请内存空间，并填充0。这里应该是主要针对bss段</span></span><br><span class="line">                           seg_page_end - seg_file_end,</span><br><span class="line">                           <span class="built_in">PFLAGS_TO_PROT</span>(phdr-&gt;p_flags),</span><br><span class="line">                           MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,</span><br><span class="line">                           <span class="number">-1</span>,</span><br><span class="line">                           <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (zeromap == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t zero fill \&quot;%s\&quot; gap: %s&quot;</span>, name_, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><font color="#006666" size="3" face="黑体">**将类型为Load的Segment映射到内存**</font></center>
接下来，soinfo_alloc方法会为该库在共享库链表中分配一个soinfo节点，并初始化其数据结构。
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> soinfo* <span class="title">load_library</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Open the file.</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open_library</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; not found&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the ELF header and load the segments.</span></span><br><span class="line">    <span class="function">ElfReader <span class="title">elf_reader</span><span class="params">(name, fd)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!elf_reader.<span class="built_in">Load</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* bname = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    soinfo* si = <span class="built_in">soinfo_alloc</span>(bname ? bname + <span class="number">1</span> : name);</span><br><span class="line">    <span class="keyword">if</span> (si == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    si-&gt;base = elf_reader.<span class="built_in">load_start</span>();</span><br><span class="line">    si-&gt;size = elf_reader.<span class="built_in">load_size</span>();</span><br><span class="line">    si-&gt;load_bias = elf_reader.<span class="built_in">load_bias</span>();</span><br><span class="line">    si-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    si-&gt;entry = <span class="number">0</span>;</span><br><span class="line">    si-&gt;dynamic = <span class="literal">NULL</span>;</span><br><span class="line">    si-&gt;phnum = elf_reader.<span class="built_in">phdr_count</span>();</span><br><span class="line">    si-&gt;phdr = elf_reader.<span class="built_in">loaded_phdr</span>();</span><br><span class="line">    <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> soinfo* <span class="title">soinfo_alloc</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(name) &gt;= SOINFO_NAME_LEN) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;library name \&quot;%s\&quot; too long&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ensure_free_list_non_empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;out of memory when loading \&quot;%s\&quot;&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Take the head element off the free list.</span></span><br><span class="line">  soinfo* si = gSoInfoFreeList;</span><br><span class="line">  gSoInfoFreeList = gSoInfoFreeList-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the new element.</span></span><br><span class="line">  <span class="built_in">memset</span>(si, <span class="number">0</span>, <span class="built_in">sizeof</span>(soinfo));</span><br><span class="line">  <span class="built_in">strlcpy</span>(si-&gt;name, name, <span class="built_in">sizeof</span>(si-&gt;name));</span><br><span class="line">  sonext-&gt;next = si;</span><br><span class="line">  sonext = si;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;name %s: allocated soinfo @ %p&quot;</span>, name, si);</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
再回过头来看下soinfo_link_image这个方法，它主要实现了动态链接库中section信息的解析：  </li>
<li>先解析dynamic section动态节区，进而实现各个Section的定位；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/11.png" alt="解析section"></li>
<li>获取其他Section的信息；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/12.png" alt="解析section"></li>
<li>待所有section信息解析完毕后，对HASH,STRTAB,SYMTAB节是否正常解析做校验；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/13.png" alt="解析section"></li>
<li>若标志位有FLAG_EXE，则表示当前程序执行的是一个可执行文件。到这里可以确定，linker不仅负责加载so，也负责解析加载一个可执行的ELF文件；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/14.png" alt="解析section"></li>
<li>加载所需要的其他共享库，其中find_library会递归调用这个so_link_image函数，直到某个so库没有DT_NEEDED段；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/15.png" alt="解析section"></li>
<li>完成rel节的重定位；<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/16.png" alt="解析section">最后，CallConstructors函数会根据动态节区中的信息，获取该共享库所依赖的所有so文件名，并在已加载的动态链接库链表中进行查找、递归调用它们的初始化函数。当运行所需的依赖库都初始化完成后，再执行init_func、init_array方法初始化该动态库。。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">soinfo::CallConstructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (constructors_called) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We set constructors_called before actually calling the constructors, otherwise it doesn&#x27;t</span></span><br><span class="line">  <span class="comment">// protect against recursive constructor calls. One simple example of constructor recursion</span></span><br><span class="line">  <span class="comment">// is the libc debug malloc, which is implemented in libc_malloc_debug_leak.so:</span></span><br><span class="line">  <span class="comment">// 1. The program depends on libc, so libc&#x27;s constructor is called here.</span></span><br><span class="line">  <span class="comment">// 2. The libc constructor calls dlopen() to load libc_malloc_debug_leak.so.</span></span><br><span class="line">  <span class="comment">// 3. dlopen() calls the constructors on the newly created</span></span><br><span class="line">  <span class="comment">//    soinfo for libc_malloc_debug_leak.so.</span></span><br><span class="line">  <span class="comment">// 4. The debug .so depends on libc, so CallConstructors is</span></span><br><span class="line">  <span class="comment">//    called again with the libc soinfo. If it doesn&#x27;t trigger the early-</span></span><br><span class="line">  <span class="comment">//    out above, the libc constructor will be called again (recursively!).</span></span><br><span class="line">  constructors_called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((flags &amp; FLAG_EXE) == <span class="number">0</span> &amp;&amp; preinit_array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// The GNU dynamic linker silently ignores these, but we warn the developer.</span></span><br><span class="line">    <span class="built_in">PRINT</span>(<span class="string">&quot;\&quot;%s\&quot;: ignoring %d-entry DT_PREINIT_ARRAY in shared library!&quot;</span>,</span><br><span class="line">          name, preinit_array_count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dynamic != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Elf32_Dyn* d = dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">      <span class="keyword">if</span> (d-&gt;d_tag == DT_NEEDED) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* library_name = strtab + d-&gt;d_un.d_val;</span><br><span class="line">        <span class="built_in">TRACE</span>(<span class="string">&quot;\&quot;%s\&quot;: calling constructors in DT_NEEDED \&quot;%s\&quot;&quot;</span>, name, library_name);</span><br><span class="line">        <span class="built_in">find_loaded_library</span>(library_name)-&gt;<span class="built_in">CallConstructors</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;\&quot;%s\&quot;: calling constructors&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DT_INIT should be called before DT_INIT_ARRAY if both are present.</span></span><br><span class="line">  <span class="built_in">CallFunction</span>(<span class="string">&quot;DT_INIT&quot;</span>, init_func);</span><br><span class="line">  <span class="built_in">CallArray</span>(<span class="string">&quot;DT_INIT_ARRAY&quot;</span>, init_array, init_array_count, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="loadLibrary之加载调用"><a href="#loadLibrary之加载调用" class="headerlink" title="loadLibrary之加载调用"></a>loadLibrary之加载调用</h2><p>Java层通过System.load或System.loadLibrary来加载一个so文件，它的定义在Android源码中的路径为&#x2F;libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;System.java，执行流程如下：<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/load2.jpg" alt="loadLibrary执行流程">接下来，让我们具体看下System.loadLibrary这个方法的实现。可以发现它实际是先通过VMStack.getCallingClassLoader()获取到ClassLoader，然后调用运行时的loadLibrary。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads and links the library with the specified name. The mapping of the</span></span><br><span class="line"><span class="comment"> * specified library name to the full path for loading the library is</span></span><br><span class="line"><span class="comment"> * implementation-dependent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> libName</span></span><br><span class="line"><span class="comment"> *            the name of the library to load.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsatisfiedLinkError</span></span><br><span class="line"><span class="comment"> *             if the library can not be loaded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadLibrary</span><span class="params">(String libName)</span> &#123;</span><br><span class="line">    loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Searches for a library, then loads and links it without security checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadLibrary</span><span class="params">(String libraryName, ClassLoader loader)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> loader.findLibrary(libraryName);</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkError</span>(<span class="string">&quot;Couldn&#x27;t load &quot;</span> + libraryName +</span><br><span class="line">                                           <span class="string">&quot; from loader &quot;</span> + loader +</span><br><span class="line">                                           <span class="string">&quot;: findLibrary returned null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">error</span> <span class="operator">=</span> doLoad(filename, loader);</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkError</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> System.mapLibraryName(libraryName);</span><br><span class="line">    List&lt;String&gt; candidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">lastError</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String directory : mLibPaths) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">candidate</span> <span class="operator">=</span> directory + filename;</span><br><span class="line">        candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">error</span> <span class="operator">=</span> doLoad(candidate, loader);</span><br><span class="line">            <span class="keyword">if</span> (error == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">            &#125;</span><br><span class="line">            lastError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastError != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkError</span>(lastError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkError</span>(<span class="string">&quot;Library &quot;</span> + libraryName + <span class="string">&quot; not found; tried &quot;</span> + candidates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码块的主要功能为：</p>
<blockquote>
</blockquote>
<ol>
<li>若ClassLoader非空，则利用ClassLoader的findLibrary方法来获取library的path；  </li>
<li>若ClassLoader为空，则根据传递进来的libraryName，获取到library file的name（比如传递“test”进来，经过System.mapLibraryName方法的调用，返回的会是“libtest.so”）。然后再在一个path list（即下面代码截图中的mLibPaths）中查找到这个library file，并最终确定library 的path；  </li>
<li>调用nativeLoad这个jni方法来load library。</li>
</ol>
<p>然而，这里其实又牵扯出了几个问题：首先，可用的library path都是哪些？这实际上也决定了我们的so文件放在哪些目录下，才可以真正的被load起来。其次，在native层的nativeLoad又是如何实现加载的？下面会对这两个问题，逐一分析介绍。。</p>
<h3 id="So的加载路径"><a href="#So的加载路径" class="headerlink" title="So的加载路径"></a>So的加载路径</h3><p>先来看看当传入的ClassLoader为空的情况(执行System.loadLibrary时并不会发生)，那么就需要关注下mLibPaths的赋值，相应代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Runtime</span> <span class="variable">mRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds the library paths, used for native library lookup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] mLibPaths = initLibPaths();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] initLibPaths() &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">javaLibraryPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.library.path&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (javaLibraryPath == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyArray.STRING;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] paths = javaLibraryPath.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="comment">// Add a &#x27;/&#x27; to the end of each directory so we don&#x27;t have to do it every time.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; paths.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!paths[i].endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            paths[i] += <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里library path list实际上读取自一个system property，直接到System.java下查看初始化代码，它其实是LD_LIBRARY_PATH环境变量的值，具体内容可以查看注释，为”&#x2F;vendor&#x2F;lib:&#x2F;system&#x2F;lib”<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/20.png" alt="library path list"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/21.png" alt="library path list">然后再来看下传入的ClassLoader非空的情况，也就是ClassLoader的findLibrary的执行过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the absolute path of the native library with the specified name,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125;. If this method returns &#123;<span class="doctag">@code</span> null&#125; then the virtual</span></span><br><span class="line"><span class="comment"> * machine searches the directories specified by the system property</span></span><br><span class="line"><span class="comment"> * &quot;java.library.path&quot;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This implementation always returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> libName</span></span><br><span class="line"><span class="comment"> *            the name of the library to find.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the absolute path of the library.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">findLibrary</span><span class="params">(String libName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果发现竟然是一个空函数，而ClassLoader本身也只是个抽象类，那系统中实际运行的ClassLoader是哪个呢？这里可以写个小程序，将实际运行的ClassLoader输出：<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/23.png" alt="小程序"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/24.png" alt="日志打印">于是，得知android系统中ClassLoader真正的实现在dalvik.system.PathClassLoader。此外，在这条日志中，还顺带将PathClassLoader初始化的参数一同打印了出来。其中，libraryPath为”&#x2F;data&#x2F;app-lib&#x2F;elf.xuexi-1”..<br>不过PathClassLoader只是继承 BaseDexClassLoader，并没有实际内容。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/25.png" alt="PathClassLoader">继续到BaseDexClassLoader下看findLibrary的实现。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/26.png" alt="BaseDexClassLoader"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/27.png" alt="BaseDexClassLoader">可以看到，这里又是在调用DexPathList类下的findLibrary。关注splitLibraryPath方法，它返回了需要加载的动态库所在目录。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/28.png" alt="DexPathList"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/29.png" alt="DexPathList">这里简单说下splitLibraryPath方法的作用，它是根据传进来的libraryPath和system property中”java.library.path”的属性值即“&#x2F;vendor&#x2F;lib:&#x2F;system&#x2F;lib”来构造出要加载的动态库所在目录列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Splits the given library directory path string into elements</span></span><br><span class="line"><span class="comment"> * using the path separator (&#123;<span class="doctag">@code</span> File.pathSeparator&#125;, which</span></span><br><span class="line"><span class="comment"> * defaults to &#123;<span class="doctag">@code</span> &quot;:&quot;&#125; on Android, appending on the elements</span></span><br><span class="line"><span class="comment"> * from the system library path, and pruning out any elements that</span></span><br><span class="line"><span class="comment"> * do not refer to existing and readable directories.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File[] splitLibraryPath(String path) &#123;</span><br><span class="line">    <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">    <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   1. this class loader&#x27;s library path for application libraries</span></span><br><span class="line">    <span class="comment">//   2. the VM&#x27;s library path from the system property for system libraries</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line">    ArrayList&lt;File&gt; result = splitPaths(path, System.getProperty(<span class="string">&quot;java.library.path&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">File</span>[result.size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Splits the given path strings into file elements using the path</span></span><br><span class="line"><span class="comment"> * separator, combining the results and filtering out elements</span></span><br><span class="line"><span class="comment"> * that don&#x27;t exist, aren&#x27;t readable, or aren&#x27;t either a regular</span></span><br><span class="line"><span class="comment"> * file or a directory (as specified). Either string may be empty</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125;, in which case it is ignored. If both strings</span></span><br><span class="line"><span class="comment"> * are empty or &#123;<span class="doctag">@code</span> null&#125;, or all elements get pruned out, then</span></span><br><span class="line"><span class="comment"> * this returns a zero-element list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;File&gt; <span class="title function_">splitPaths</span><span class="params">(String path1, String path2,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> wantDirectories)</span> &#123;</span><br><span class="line">    ArrayList&lt;File&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;File&gt;();</span><br><span class="line">    splitAndAdd(path1, wantDirectories, result);</span><br><span class="line">    splitAndAdd(path2, wantDirectories, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helper for &#123;<span class="doctag">@link</span> #splitPaths&#125;, which does the actual splitting</span></span><br><span class="line"><span class="comment"> * and filtering and adding to a result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">splitAndAdd</span><span class="params">(String searchPath, <span class="type">boolean</span> directoriesOnly,</span></span><br><span class="line"><span class="params">        ArrayList&lt;File&gt; resultList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (searchPath == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String path : searchPath.split(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">StructStat</span> <span class="variable">sb</span> <span class="operator">=</span> Libcore.os.stat(path);</span><br><span class="line">            <span class="keyword">if</span> (!directoriesOnly || S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">                resultList.add(<span class="keyword">new</span> <span class="title class_">File</span>(path));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以对动态链接库的加载路径做个总结了，系统默认的目录为”&#x2F;vendor&#x2F;lib”和”&#x2F;system&#x2F;lib”。当使用System.loadLibrary或System.load来加载一个共享库的时候，会将VM栈中的ClassLoader传入。之后调用findLibrary方法，在两个目录中去寻找指定的so文件：一个是构造ClassLoader时，传进来的那个libraryPath；另一个则是system property中”java.library.path”的属性值。也就是说，实际上是会在如下的3个目录中进行查找：</p>
<blockquote>
</blockquote>
<ol>
<li>“&#x2F;vendor&#x2F;lib”</li>
<li>“&#x2F;system&#x2F;lib”</li>
<li>“&#x2F;data&#x2F;app-lib&#x2F;包名-n”</li>
</ol>
<p>对于”&#x2F;data&#x2F;app-lib&#x2F;包名-n”这个路径，大家可能会比较陌生，但应该都知道”&#x2F;data&#x2F;data&#x2F;包名&#x2F;lib”目录，这里就简单讲解下apk安装过程中的一点细节，以说明二者之间的关系（在Android源码中的路径为”&#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;installd&#x2F;commands.c”）  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">install</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgname, <span class="type">uid_t</span> uid, <span class="type">gid_t</span> gid, <span class="type">const</span> <span class="type">char</span> *seinfo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> pkgdir[PKG_PATH_MAX];</span><br><span class="line">    <span class="type">char</span> libsymlink[PKG_PATH_MAX];</span><br><span class="line">    <span class="type">char</span> applibdir[PKG_PATH_MAX];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">libStat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uid &lt; AID_SYSTEM) || (gid &lt; AID_SYSTEM)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;invalid uid/gid: %d %d\n&quot;</span>, uid, gid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_pkg_path(pkgdir, pkgname, PKG_DIR_POSTFIX, <span class="number">0</span>)) &#123;  <span class="comment">//创建包路径，&quot;/data/data/包名&quot;</span></span><br><span class="line">        ALOGE(<span class="string">&quot;cannot create package path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_pkg_path(libsymlink, pkgname, PKG_LIB_POSTFIX, <span class="number">0</span>)) &#123;  <span class="comment">//创建库路径，&quot;/data/data/包名/lib&quot;</span></span><br><span class="line">        ALOGE(<span class="string">&quot;cannot create package lib symlink origin path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_pkg_path_in_dir(applibdir, &amp;android_app_lib_dir, pkgname, PKG_DIR_POSTFIX)) &#123;  <span class="comment">//创建&quot;/data/app-lib/包名&quot;目录</span></span><br><span class="line">        ALOGE(<span class="string">&quot;cannot create package lib symlink dest path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mkdir(pkgdir, <span class="number">0751</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot create dir &#x27;%s&#x27;: %s\n&quot;</span>, pkgdir, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chmod(pkgdir, <span class="number">0751</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot chmod dir &#x27;%s&#x27;: %s\n&quot;</span>, pkgdir, strerror(errno));</span><br><span class="line">        unlink(pkgdir);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lstat(libsymlink, &amp;libStat) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != ENOENT) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;couldn&#x27;t stat lib dir: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(libStat.st_mode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (delete_dir_contents(libsymlink, <span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;couldn&#x27;t delete lib directory during install for: %s&quot;</span>, libsymlink);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(libStat.st_mode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unlink(libsymlink) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;couldn&#x27;t unlink lib directory during install for: %s&quot;</span>, libsymlink);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (symlink(applibdir, libsymlink) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;couldn&#x27;t symlink directory &#x27;%s&#x27; -&gt; &#x27;%s&#x27;: %s\n&quot;</span>, libsymlink, applibdir,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        unlink(pkgdir);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selinux_android_setfilecon2(pkgdir, pkgname, seinfo, uid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot setfilecon dir &#x27;%s&#x27;: %s\n&quot;</span>, pkgdir, strerror(errno));</span><br><span class="line">        unlink(libsymlink);</span><br><span class="line">        unlink(pkgdir);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chown(pkgdir, uid, gid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot chown dir &#x27;%s&#x27;: %s\n&quot;</span>, pkgdir, strerror(errno));</span><br><span class="line">        unlink(libsymlink);</span><br><span class="line">        unlink(pkgdir);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会先构造几个目录名：pkgdir为”&#x2F;data&#x2F;data&#x2F;包名”，libsymlink为”&#x2F;data&#x2F;data&#x2F;包名&#x2F;lib”，applibdir为”&#x2F;data&#x2F;app-lib&#x2F;包名”。然后创建相应目录，并赋权限。之后，建立”&#x2F;data&#x2F;data&#x2F;包名&#x2F;lib”指向”&#x2F;data&#x2F;app-lib&#x2F;包名”的符号链接。<br>现在再回过头来说明下”&#x2F;data&#x2F;app-lib&#x2F;包名-n”、”&#x2F;data&#x2F;data&#x2F;包名&#x2F;lib”这二者之间的关系。在”&#x2F;data&#x2F;data&#x2F;包名&#x2F;“目录下执行ls –l命令，就会发现lib是一个链接，So其实是放在”&#x2F;data&#x2F;app-lib&#x2F;包名-n”路径下的。。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/30.png" alt="ls -l"></p>
<h3 id="Native-层的加载实现"><a href="#Native-层的加载实现" class="headerlink" title="Native 层的加载实现"></a>Native 层的加载实现</h3><p>doLoad实际上是调用本地的nativeLoad方法，nativeLoad会先更新LD_LIBRARY_PATH，然后执行dvmLoadNativeCode函数，真正实现so文件的加载。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * static String nativeLoad(String filename, ClassLoader loader, String ldLibraryPath)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Load the specified full path as a dynamic library filled with</span></span><br><span class="line"><span class="comment"> * JNI-compatible methods. Returns null on success, or a failure</span></span><br><span class="line"><span class="comment"> * message on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Dalvik_java_lang_Runtime_nativeLoad</span><span class="params">(<span class="type">const</span> u4* args,</span></span></span><br><span class="line"><span class="params"><span class="function">    JValue* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StringObject* fileNameObj = (StringObject*) args[<span class="number">0</span>];</span><br><span class="line">    Object* classLoader = (Object*) args[<span class="number">1</span>];</span><br><span class="line">    StringObject* ldLibraryPathObj = (StringObject*) args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(fileNameObj != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span>* fileName = <span class="built_in">dvmCreateCstrFromString</span>(fileNameObj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ldLibraryPathObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* ldLibraryPath = <span class="built_in">dvmCreateCstrFromString</span>(ldLibraryPathObj);</span><br><span class="line">        <span class="type">void</span>* sym = <span class="built_in">dlsym</span>(RTLD_DEFAULT, <span class="string">&quot;android_update_LD_LIBRARY_PATH&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sym != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fn)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line">            Fn android_update_LD_LIBRARY_PATH = <span class="built_in">reinterpret_cast</span>&lt;Fn&gt;(sym);</span><br><span class="line">            (*android_update_LD_LIBRARY_PATH)(ldLibraryPath);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;android_update_LD_LIBRARY_PATH not found; .so dependencies will not work!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(ldLibraryPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringObject* result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* reason = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="built_in">dvmLoadNativeCode</span>(fileName, classLoader, &amp;reason);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* msg = (reason != <span class="literal">NULL</span>) ? reason : <span class="string">&quot;unknown failure&quot;</span>;</span><br><span class="line">        result = <span class="built_in">dvmCreateStringFromCstr</span>(msg);</span><br><span class="line">        <span class="built_in">dvmReleaseTrackedAlloc</span>((Object*) result, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(reason);</span><br><span class="line">    <span class="built_in">free</span>(fileName);</span><br><span class="line">    <span class="built_in">RETURN_PTR</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dvmLoadNativeCode定义在Android源码中的路径为&#x2F;dalvik&#x2F;vm&#x2F;Native.cpp，它的主要功能如下：  </p>
<ol>
<li>调用findSharedLibEntry方法，遍历查找已加载的lib。具体来说，就是先用待加载的lib路径名计算出一个32位hash值，然后遍历gDvm中的nativeLibs（其结构为HashTable用来保存加载的本地库），如果找到则返回一个SharedLib结构。这里如果LIB已被加载，则会对其加载的ClassLoader进行比较，JNI只允许同一个LIB只被一个ClassLoader加载;<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/31.png" alt="dvmLoadNativeCode"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/32.png" alt="dvmLoadNativeCode"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/33.png" alt="dvmLoadNativeCode"></li>
<li>调用dlopen打开一个so;<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/34.png" alt="dvmLoadNativeCode"></li>
<li>将新加载的LIB插入到gDvm保存的链表中，执行JNI_OnLoad的调用。<br><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/35.png" alt="dvmLoadNativeCode"><img src="/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/36.png" alt="dvmLoadNativeCode"></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在了解So在内存中的加载原理后，可以得知以下几点：</p>
<blockquote>
</blockquote>
<ol>
<li>So的加载路径为：”&#x2F;vendor&#x2F;lib”、”&#x2F;system&#x2F;lib”、”&#x2F;data&#x2F;app-lib&#x2F;包名-n”;</li>
<li>So的入口为init_array、init_func这些初始化函数。这部分在dlopen的过程中就会执行，再之后的是JNI_Onload方法的调用。这里面可以注册一些本地方法，也可以继续做些变量的初始化等操作;</li>
<li>在So的加载流程中，最终会被存放到SharedLib这个结构体中，并添加到nativeLibs这个hash表下。。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2015/04/09/%E7%BB%86%E8%AF%B4So%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" data-id="cl4bh8h7w001yp8w193kmg9kl" data-title="细说So动态库的加载流程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/" rel="tag">ELF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ELF文件结构详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2015-04-01T06:48:20.000Z" itemprop="datePublished">2015-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/">ELF文件结构详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="链接与装载视图"><a href="#链接与装载视图" class="headerlink" title="链接与装载视图"></a>链接与装载视图</h2><p>Elf文件有2个平行视角：一个是程序链接角度，一个是程序装载角度。从链接的角度来看，Elf文件是按“Section”（节）的形式存储；而在装载的角度上，Elf文件又可以按“Segment”（段）来划分。实际上，Section和Segment难以从中文的翻译上加以区分。因为很多时候Section也被翻译成段，比如Section Header Table，有的资料叫段表、有的称为节区。后面在讲解时，就不对其加以区分。。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/1.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/2.png" alt="ELF"></p>
<h2 id="关于动态链接与静态链接"><a href="#关于动态链接与静态链接" class="headerlink" title="关于动态链接与静态链接"></a>关于动态链接与静态链接</h2><p>链接分为2种方式：一种是静态链接、一种是动态链接。<br>静态链接是在编译链接时直接将需要执行的代码拷贝到调用处；动态链接则是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，由系统负责将所需的动态库加载到内存，然后当程序运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时链接的目的。<br>程序是静态链接还是动态链接，由编译器的链接参数指定。具体来说，在Android上用C++进行ndk编程时，可以通过设置Application.mk的相关内容，将相应的运行库作为动态库或静态库。</p>
<h2 id="编写例子so"><a href="#编写例子so" class="headerlink" title="编写例子so"></a>编写例子so</h2><p>为了方便自己学习和记忆，编写了一个例子so。这里我仅贴了部分代码，用于后面的分析与测试。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/3.png" alt="ELF"></p>
<h2 id="目标文件中的数据类型"><a href="#目标文件中的数据类型" class="headerlink" title="目标文件中的数据类型"></a>目标文件中的数据类型</h2><p>在介绍Elf文件格式前，先看看Elf文件中用到的数据类型：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Size</th>
</tr>
</thead>
<tbody><tr>
<td>Elf32_Addr</td>
<td>4</td>
</tr>
<tr>
<td>Elf32_Half</td>
<td>2</td>
</tr>
<tr>
<td>Elf32_Off</td>
<td>4</td>
</tr>
<tr>
<td>Elf32_Sword</td>
<td>4</td>
</tr>
<tr>
<td>Elf32_Word</td>
<td>4</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1</td>
</tr>
</tbody></table>
<h2 id="Elf文件头"><a href="#Elf文件头" class="headerlink" title="Elf文件头"></a>Elf文件头</h2><p>Elf文件头描述了整个文件基本属性，如段表偏移、程序头部偏移等重要信息。它的定义如下：<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/4.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/5.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/6.png" alt="ELF"></p>
<h2 id="节区头部（段表）"><a href="#节区头部（段表）" class="headerlink" title="节区头部（段表）"></a>节区头部（段表）</h2><p>前面有提过，Elf文件链接时是以Section的形式进行存储。其中，节区头部（段表）就是保存这些Section基本属性的结构。它描述了Elf中各个节的信息，比如每个节的名称、长度、在文件中的偏移、读写权限及其他属性，是一个以Elf32_Shdr结构体为元素的数组，而这个结构体又被称为段描述符。<br>因为sh_name是在段表字符串表中的索引，所以实际在解析时需要先定位到.shstrtab表，该表是专门用来存放Section名称的字符串表。而它对应的描述符在段表数组中的下标，则在Elf文件头中有给出，通常都是最后一个下标。在拿到节区名称后，再通过sh_offset、sh_size确定每一个节区在文件中的位置与长度。<br>最后，用readelf命令来查看下目标文件中的段，对照相应输出来分析确认段表结构(PS：段表数组中，第一个元素总是无效的描述符，全部为0)<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/7.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/8.png" alt="ELF"></p>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>.text代码段中保存程序指令，具体可以去查看arm、thumb指令集的opcode。。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/9.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/10.png" alt="ELF"></p>
<h2 id="数据段和只读数据段"><a href="#数据段和只读数据段" class="headerlink" title="数据段和只读数据段"></a>数据段和只读数据段</h2><p>“.rodata”段存放的是只读数据，一般是程序里的只读变量（如const修饰的变量）和字符串常量；”.data”段保存的是已经初始化的全局静态变量和局部静态变量。<br>PS：有时候编译器会把字符串常量放到”.data”段，而不是单独放到”.rodata”只读数据段。</p>
<h2 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h2><p>.bss段中存放的是未初始化的全局变量和局部静态变量，这个Section在Elf文件中没有被分配空间。。</p>
<h2 id="自定义section"><a href="#自定义section" class="headerlink" title="自定义section"></a>自定义section</h2><p>在声明一个函数或变量时，可以加上__attribute__((section(“自定义section名”)))前缀的方式，将其添加到自定义段。</p>
<h2 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h2><p>Elf文件中用到的字符串，如段名、函数名、变量名称等，均保存在字符串表中。其中，shstrtab段表字符串表仅用来保存段名，而strtab或dynstr section则是存放普通字符串，如函数、变量名等符号名称，字符串之间以”00”截断。。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/11.png" alt="ELF"></p>
<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>在链接过程中，函数和变量统称为符号，函数名或变量名就是符号名。符号表的段名为symtab或dynsym，它是一个Elf32_Sym结构的数组。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/12.png" alt="ELF">使用readelf命令来查看目标文件的符号信息：<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/13.png" alt="ELF">从以上输出可以看到，第一个元素即下标为0的符号，总是一个未定义的符号。<br>其中st_size符号大小，它的取值有以下几种情况：对于数据类型的符号，它的值为该数据类型的大小；对于函数类型的符号，它的值为该方法的长度；如果该值为0，表示该符号大小为0或未知。<br>一般情况下，st_value符号值，为相应符号的偏移（“COMMON”块除外，表示该符号的对齐属性）。如本地定义的JNI_OnLoad方法，这个符号的值为0xdcd，实际上这个函数的地址就是0xdcc（因为指令集的切换加1）。<br>此外，让我们注意下红框中的几个符号。其中printf、__android_log_print这2个符号因为定义在其他库文件中，所以对应的符号值和大小都是0；而全局变量a和声明的全局函数指针global_printf的符号值，分别为0x4010、0x4014，都已经超过了文件长度，那么这些值实际上是在表示什么呢？通过动态调试，我们得知它其实是程序在内存中的虚拟地址。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/14.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/15.png" alt="ELF">这里再简单说明下，在链接过程中，链接器并不关心模块内部的非导出符号，如start这个函数。它是通过本地注册的方式声明的，实际寻址时可以通过registerNatives找到该方法，像这种函数会被编译器优化掉，变成偏移。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/16.png" alt="ELF">PS：对符号表的理解，是elf hook的基础（导出表、导入表Hook）</p>
<h2 id="程序解释器"><a href="#程序解释器" class="headerlink" title="程序解释器"></a>程序解释器</h2><p>“.interp”段用于指定解释器路径，里面保存的就是一个字符串，Android下固定为”&#x2F;system&#x2F;bin&#x2F;linker”  <img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/17.png" alt="ELF"></p>
<h2 id="全局偏移表（GOT）"><a href="#全局偏移表（GOT）" class="headerlink" title="全局偏移表（GOT）"></a>全局偏移表（GOT）</h2><p>在位置无关代码中，一般不能包含绝对虚拟地址。当在程序中引用某个共享库中的符号时，编译链接阶段并不知道这个符号的具体位置，如上面的__android_log_print，只有等到动态链接器将所需要的共享库加载到内存后，也就是运行阶段，符号的地址才会最终确定。因此，需要有一个数据结构来保存符号的绝对地址，这便是GOT表。这样，程序就可以通过引用GOT来获得某个符号的地址。<br>在Linux下，GOT被拆分成”.got”和”.got.plt”2个表。其中”.got”用来保存全局变量引用的地址，”.got.plt”用来保存函数引用的地址。此外，”.got.plt”的前三项保留，用于存放特殊的数据结构地址：第一项保存的是”.dynamic”动态节区的地址；第二项保存的是本模块ID，指向已经加载的共享库的链表地址（前面提到加载的共享库会形成一个链表）；第三项保存的是_dl_runtime_ resolve函数的地址（用于查找指定模块下的特定方法）.<br>而在Android平台，got表并没有细分”.got”、”.got.plt”，但仔细观察可以发现，它其实有通过_GLOBAL_OFFSET_TABLE_来区分上下两个结构。。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/18.png" alt="ELF"></p>
<h2 id="过程链接表（PLT）"><a href="#过程链接表（PLT）" class="headerlink" title="过程链接表（PLT）"></a>过程链接表（PLT）</h2><p>在支持懒绑定的情况下，当发生对外部函数的调用时，程序会通过PLT表将控制交给动态链接器，后者解析出函数的绝对地址，修改GOT中相应的值，之后的调用将不再需要链接器的绑定。Android虽然内核基于Linux，但其动态链接机制却不是ld.so而是自带的linker。由于linker是不支持懒绑定的，所以在进程初始化时，动态链接器首先解析出外部过程引用的绝对地址，一次性的修改所有相应的GOT表项。<br>基于上文的说明，再来简单分析下Android平台中Elf文件的PLT过程链接表。可以发现，plt其实也是代码段，除PLT[0]外，其它所有PLT项的形式都一样，且包括PLT[0]在内的每个表项都占16个字节，所以整个PLT就像个数组。其中，PLT[0]内容固定，跳转到GOT[2]即_dl_runtime_ resolve函数，查找特定模块下的指定方法，并填充到GOT表。而其他PLT普通表项则相当于一个函数的桩函数（stub），通过引用GOT表中函数的绝对地址，来把控制转移到实际的函数。<br>PS：这一部分知识可以用来实现GOT、PLT表hook，即导入表hook。。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/19.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/20.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/21.png" alt="ELF"></p>
<h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>在前面介绍符号表、got表、plt表时，其实就已经涉及到了重定位。重定位是将符号引用与符号定义进行链接的过程。例如，当程序调用了一个函数时，相关的调用指令必须把控制传输到适当的目标执行地址。<br>在Elf文件中，以”.rel”或”.rela”开头的section就是一个重定位段。它是一个Elf32_Rel结构数组，每个元素对应一个重定位入口。<br>本例中的重定位表是”.rel.dyn”和”.rel.plt”，它们分别相当于静态链接中的”.rel.data”和”.rel.text”。”.rel.dyn”实际上是对数据引用的修正，它所修正的位置相当于”.got “以及数据段；而”.rel.plt”则是对函数引用的修正，所修正的位置位于”.got.plt”。然后，使用”readelf -r”命令，查看重定位表，并依此进行对比分析。。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/22.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/23.png" alt="ELF">接下来，结合代码看看Android系统的Linker是如何实现重定位的。将例子so拖到Ida中，查找到对应start方法的偏移函数。然后，将几个重要的地址先找出来，分别是：<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/24.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/25.png" alt="ELF"></p>
<h3 id="全局函数指针调用外部函数"><a href="#全局函数指针调用外部函数" class="headerlink" title="全局函数指针调用外部函数"></a>全局函数指针调用外部函数</h3><p>global_printf方法是我们声明的指向printf函数的全局指针，调用global_printf方法时，R3的值是*global_printf，而global_printf的值0x4010刚好在.rel.dyn中的R_ARM_ABS32的重定位项，因此可以得出结论：通过全局函数指针的方式调用外部函数，它的重定位类型是R_ARM_ABS32，并且位于.rel.dyn 节区。<br>继续分析global_printf的调用流程的调用流程，首先定位到global_printf_ptr（0x3FD0），该地址位于.got 节区，GLOBAL_OFFSET_TABLE的上方。然后再通过global_printf_ptr 定位到0x4010（位于.data节区），最后再通过0x4010 定位到最终的函数地址，因此R_ARM_ABS32重定位项的Offset指向最终调用函数地址的地址（也就是函数指针的指针），整个重定位过程是先位到.got，再从.got 定位到.date。下面是.got 段区的16进制表示：<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/26.png" alt="ELF">结果发现0x4028地址中的数据全为0，当动态链接时，linker会覆盖0x00004010地址的值，指向printf的真正地址（而不是现在的0x00004028）</p>
<h3 id="直接调用外部函数"><a href="#直接调用外部函数" class="headerlink" title="直接调用外部函数"></a>直接调用外部函数</h3><p>再来看下直接调用printf函数时的情况，对应0xD16的BLX 指令，它会跳转.plt节。最后，PC指向*printf_ptr，其中printf_ptr的地址为0x3FE8，位于.got.plt 节区，而0x3FE8 地址值的正好是前面有提到的0x4028，于是可以得出结论：直接调用外部函数，它的重定位类型是R_ARM_JUMP_SLOT，位于.re.plt 节区，其Offset指向最终调用函数地址的地址（也就是函数指针的指针）。整个过程是先到.plt，再到.got，最后才定位到真正的函数地址。。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/27.png" alt="ELF"></p>
<h2 id="动态节区（dynamic）"><a href="#动态节区（dynamic）" class="headerlink" title="动态节区（dynamic）"></a>动态节区（dynamic）</h2><p>Dynamic段是动态链接中Elf最重要的一个section，这里面保存了动态链接器所需的基本信息，如依赖于哪些共享对象、动态链接符号表的位置、共享对象初始化代码的地址等。<br>动态节区是一个数组，每个元素都是Elf32_dyn结构体。它的定义如下所示，由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或指针有着不同含义。。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/28.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/29.png" alt="ELF"></p>
<h2 id="程序头表（Program-Header-Table）"><a href="#程序头表（Program-Header-Table）" class="headerlink" title="程序头表（Program Header Table）"></a>程序头表（Program Header Table）</h2><p>前面已经就链接视图将重要的一些Section做了详尽解析，这里再从装载角度介绍下程序头表，它是一个以Elf32_Phdr结构体为元素的数组。<br>然后，再来简单介绍下Segment这个概念。因为程序在加载的过程中，是根据权限映射到内存空间的，而一个Segment可以包含一个或多个属性类似的Section。<br>其中，p_memsz的值不可以小于p_filesz，否则就是不符合常理的。如果p_memsz大于p_filesz，就表示该Segment在内存中所分配的空间超过在文件中的实际大小，多余的部分全部填充0，如BSS段。。<br>使用readelf命令查看程序头表，进行对比分析。其中第一项Program Header，用来描述程序头表自身的位置和大小；第二项和第三项为Load Segment，只有这部分会被加载到内存，并因为权限属性的不同，被划分成了多个部分（具体到这个so则是2块）。它包括代码段、数据段等；第三项是Dynamic Segment，它提供了Dynamic动态节区的偏移和大小，并通过寻址到Dynamic节进而获取动态链接器所需的基本信息。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/30.png" alt="ELF"><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/31.png" alt="ELF">使用“cat &#x2F;proc&#x2F;pid&#x2F;maps”命令，查看libtest.so在内存中的映射，发现它被分成了3个子空间，继续看第二列。其中，r表示只读，w表示可写，x表示可执行，p表示私有（s表示共享）。这一部分基本对应前面的程序头表，至于为什么会多出一块只读部分，个人的理解是程序头表只是根据权限将属性相近的段划到一个Segment，加载的时候还是按照权限进行映射的。最明显的就是，rodata只读数据段和代码段放到了一个Segment，但代码段是可读可执行的。<br><img src="/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/32.png" alt="ELF">最后，再来简单的说下页对齐。在进行内存映射时，实际是以一个“页（Page）”为单位进行映射的，而在Android平台下，页的单位为0x1000（4096）字节。这里再来看下上图中的第一行信息，libtest.so映射到内存空间中的起始地址为0x403ec000，这一块地址空间的权限为可读可执行，在程序头表中相应的Load段的大小为0x2444，二者相加为0x403EE444。但是，它的结束地址却不是0x403EE444，而是0x403ef000，多出的那一部分字节正是为了做页对齐。。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，Elf文件结构的学习和总结告一段落。这部分知识，可以应用在Elf hook和Elf的加固上，其中Elf hook已经有了一个简单的认识，后续有时间我会进行相关说明并整理相应的代码实现。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2015/04/01/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/" data-id="cl4bh8h7h0005p8w1c1fwgf5x" data-title="ELF文件结构详解" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/" rel="tag">ELF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" rel="tag">文件格式</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/">智能设备</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%89%A9%E8%81%94%E7%BD%91/">物联网</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E/">虚拟现实</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%BB%91%E4%BA%A7%E7%A0%94%E7%A9%B6/">黑产研究</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BLE/" rel="tag">BLE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ELF/" rel="tag">ELF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ROM/" rel="tag">ROM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/" rel="tag">业务安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E6%B7%B7%E6%B7%86/" rel="tag">反混淆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" rel="tag">学习总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/" rel="tag">恶意代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" rel="tag">文件格式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B/" rel="tag">模拟器检测</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B4%E6%92%AD%E4%BA%BA%E6%B0%94/" rel="tag">直播人气</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/" rel="tag">知识梳理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%83%E7%A0%94/" rel="tag">调研</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%86%E5%90%91/" rel="tag">逆向</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/" rel="tag">重放攻击</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BLE/" style="font-size: 13.33px;">BLE</a> <a href="/tags/ELF/" style="font-size: 20px;">ELF</a> <a href="/tags/ROM/" style="font-size: 10px;">ROM</a> <a href="/tags/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/" style="font-size: 10px;">业务安全</a> <a href="/tags/%E5%8F%8D%E6%B7%B7%E6%B7%86/" style="font-size: 10px;">反混淆</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" style="font-size: 10px;">学习总结</a> <a href="/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">恶意代码</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" style="font-size: 10px;">文件格式</a> <a href="/tags/%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B/" style="font-size: 13.33px;">模拟器检测</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 16.67px;">源码分析</a> <a href="/tags/%E7%9B%B4%E6%92%AD%E4%BA%BA%E6%B0%94/" style="font-size: 10px;">直播人气</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/" style="font-size: 13.33px;">知识梳理</a> <a href="/tags/%E8%B0%83%E7%A0%94/" style="font-size: 13.33px;">调研</a> <a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 13.33px;">逆向</a> <a href="/tags/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/" style="font-size: 10px;">重放攻击</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/28/OLLVM%E9%80%9A%E7%94%A8%E5%8F%8D%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%A0%94%E7%A9%B6/">OLLVM通用反平坦化研究</a>
          </li>
        
          <li>
            <a href="/2018/05/10/Android%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86/">Android模拟器检测体系梳理</a>
          </li>
        
          <li>
            <a href="/2018/04/21/%E8%B5%B7%E5%BA%95%E8%96%85%E7%BE%8A%E6%AF%9B%E7%81%B0%E8%89%B2%E4%BA%A7%E4%B8%9A%E9%93%BE/">起底薅羊毛灰色产业链</a>
          </li>
        
          <li>
            <a href="/2018/03/10/%E5%9F%BA%E4%BA%8ECache%E7%9A%84Android%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B/">基于Cache的Android模拟器检测</a>
          </li>
        
          <li>
            <a href="/2018/02/26/%E5%85%AD%E9%97%B4%E6%88%BF%E7%9B%B4%E6%92%AD%E5%88%B7%E4%BA%BA%E6%B0%94/">六间房直播刷人气</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>